// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Combined & Enhanced by Antigravity (QUANTUM NOVA: PLATINUM V2)

//@version=5
strategy("QUANTUM NOVA: Bloomberg Terminal [Platinum+]", overlay = true, max_boxes_count = 500, max_labels_count = 500, max_lines_count = 500, max_bars_back = 5000, initial_capital = 10000, default_qty_type = strategy.percent_of_equity, default_qty_value = 10, currency = currency.USD)

// =============================================================================
// 1. MASTER CONFIGURATION
// =============================================================================
grp_gen = "âš™ï¸ GENERAL SETTINGS"
show_dash   = input.bool(true, "Tampilkan Dashboard Bloomberg", group = grp_gen)
dash_pos    = input.string("Top Right", "Posisi Dashboard", options = ["Top Right", "Bottom Right", "Bottom Left", "Top Left", "Middle Right"], group = grp_gen)
use_indo    = input.bool(true, "Bahasa Indonesia", group = grp_gen)

grp_vis = "ðŸŽ¨ VISUAL CUSTOMIZATION"
show_signals= input.bool(true, "Tampilkan Label Sinyal (Custom)", group = grp_vis)
col_buy     = input.color(#00FF00, "Warna Sinyal BUY", group = grp_vis)
col_sell    = input.color(#FF0000, "Warna Sinyal SELL", group = grp_vis)
sz_input    = input.string("Small", "Ukuran Label Sinyal", options = ["Tiny", "Small", "Normal", "Large", "Huge"], group = grp_vis)
show_tpsl   = input.bool(true, "Gambar Garis TP/SL (Enhanced)", group = grp_vis)

grp_strat = "ðŸ§  STRATEGY & INDICATORS"
rsi_len     = input.int(14, "RSI Length", group = grp_strat)
rsi_src     = input.source(close, "RSI Source", group = grp_strat)
use_smc     = input.bool(true, "Smart Money (OB + FVG)", group = grp_strat)
use_utbot   = input.bool(true, "Volatility Bot (UT Bot)", group = grp_strat)
use_super   = input.bool(true, "Supertrend (Trend)", group = grp_strat)

grp_pat = "ðŸ•¯ï¸ CANDLE PATTERNS (NEW)"
show_engulf = input.bool(true, "Show Engulfing Candles", group = grp_pat)
col_bull_eng = input.color(color.new(color.green, 0), "Bullish Engulfing Color", group = grp_pat)
col_bear_eng = input.color(color.new(color.red, 0), "Bearish Engulfing Color", group = grp_pat)

grp_ema = "ðŸ“ˆ 3 EMA (NEW)"
show_ema = input.bool(true, "Show 3 EMA", group = grp_ema)
len_ema1 = input.int(17, "Fast EMA Length", minval=1, group = grp_ema)
len_ema2 = input.int(72, "Medium EMA Length", minval=1, group = grp_ema)
len_ema3 = input.int(305, "Slow EMA Length", minval=1, group = grp_ema)
src_ema1 = input.source(close, "Source Fast", group = grp_ema)
src_ema2 = input.source(close, "Source Medium", group = grp_ema)
src_ema3 = input.source(close, "Source Slow", group = grp_ema)
col_ema1 = input.color(color.fuchsia, "Color EMA 1", group = grp_ema)
col_ema2 = input.color(color.orange, "Color EMA 2", group = grp_ema)
col_ema3 = input.color(color.blue, "Color EMA 3", group = grp_ema)

grp_risk = "ðŸ’° RISK MANAGEMENT"
tp_mult     = input.float(3.0, "Reward Ratio (TP)", group = grp_risk)
sl_mult     = input.float(1.0, "Risk Ratio (SL)", group = grp_risk)

// --- FLUX CHARTS CONFIGURATION (INTEGRATED) ---
grp_flux = "ðŸ§¬ FLUX CHARTS VOLUME BLOCKS"
showInvalidated = input.bool(true, "Show Historic Zones", group = grp_flux)
orderBlockVolumetricInfo = input.bool(true, "Volumetric Info", group = grp_flux)
obEndMethod = input.string("Wick", "Zone Invalidation", options = ["Wick", "Close"],  group = grp_flux)
combineOBs = true 
maxATRMult = 3.5
swingLength = input.int(10, 'Swing Length', minval = 3, tooltip="Swing length used for OB detection", group = grp_flux)
flux_zoneCount = input.string("Low", 'Zone Count', options = ["High", "Medium", "Low", "One"], group = grp_flux)
bullOrderBlockColor = input(#08998180, 'Bullish Zone Color', group = grp_flux)
bearOrderBlockColor = input(#f2364680, 'Bearish Zone Color', group = grp_flux)
flux_textColor = input.color(#ffffff80, "Text Color", group = grp_flux)

// --- SCRIPT 1: MTF BOS & MSS (Lenny) ---
// Constants
Transparent_Color = color.new(color.white, 100)

// Groups
General_Settings_group = "-------General Settings-------"
Timeframe_1_Group  = "-------Timeframe 1 Settings--------"
Timeframe_2_Group  = "-------Timeframe 2 Settings--------"
Timeframe_3_Group  = "-------Timeframe 3 Settings--------"

// Tooltips
Hide_MS_Tooltip = "If true will hide all MS plots such as \"HH 2H\" or \"HH 15min\""
Hide_Breaks_Tooltip = "If true will hide all MS breaks such as \"BOS 1H\" or \"MSS 15min\""
Timeframe_Tooltip = "If set to chart is true no need to alter these two inputs."
Set_To_Chart_Tooltip = "If set to chart is set to true, there is no need to alter the Timeframe inputs, it will automatically configure itself to the charts timeframe."
Lower_Timeframe_Tooltip = "If set to true and chart timeframe is higher than the choosen timeframe, structure will not display. Note plotting ltf structure on a htf will provide inaccurate plots."
Use_High_Low_Tooltip = "If set to true high and low values will be used to confirm market structure else if set to false close will be used."
Display_TF_Pivots = "If true the script will display the timeframe declared in the TF inputs"
Display_TF_MS = "If true the script will display the timeframe's market structure declared in the TF inputs if Hide all Market Structure is false in general settings."
BOS_Alert_Tooltip = "Set to true to activate BOS alerts then proceed to set the any alert function specifically on this script."
MSS_Alert_Tooltip = "Set to true to activate MSS alerts then proceed to set the any alert function specifically on this script."
BOS_Plot_Tooltip = "If set to true the TF BOS plots will be plotted else if false they will be hidden."
MSS_Plot_Tooltip = "If set to true the TF MSS plots will be plotted else if false they will be hidden."

// General Settings
Hide_All_MS = input.bool(defval = true, title = "Hide all Market Structure", group = General_Settings_group, tooltip = Hide_MS_Tooltip)
Hide_All_Breaks = input.bool(defval = false, title = "Hide all Structure Breaks", group = General_Settings_group, tooltip = Hide_Breaks_Tooltip)
Show_Only_On_Lower_Timeframes = input.bool(defval = true, title = "Show Structure only on a lower Timeframe", group = General_Settings_group, tooltip = Lower_Timeframe_Tooltip)

// User Inputs
// Timeframe 1 Settings
TF_1_Use_Bos_Plot = input.bool(defval = true, title = "Show TF 1 BOS Plots", group = Timeframe_1_Group, tooltip = BOS_Plot_Tooltip)
TF_1_Use_MSS_Plot = input.bool(defval = true, title = "Show TF 1 MSS Plots", group = Timeframe_1_Group, tooltip = MSS_Plot_Tooltip)
TF_1_Chart_Feature = input.bool(defval = false, title = "Set Timeframe to Chart", group = Timeframe_1_Group, tooltip = Set_To_Chart_Tooltip)
TF_1_Use_High_Low = input.bool(defval = false, title = "Use High/Low for Bos & Mss", group = Timeframe_1_Group, tooltip = Use_High_Low_Tooltip)
TF_1_Display_Pivots = input.bool(defval = true, title = "Display Market Structure", group = Timeframe_1_Group, tooltip = Display_TF_MS)
TF_1_Display_Timeframe = input.bool(defval = true, title = "Display Timeframe", group = Timeframe_1_Group, tooltip = Display_TF_Pivots)
TF_1_BOS_Alert = input.bool(defval = true, title = "Use TF 1 BOS Alert", group = Timeframe_1_Group, tooltip = BOS_Alert_Tooltip)
TF_1_MSS_Alert = input.bool(defval = true, title = "Use TF 1 MSS Alert", group = Timeframe_1_Group, tooltip = MSS_Alert_Tooltip)
TF_1_Multip = input.int(defval=2, minval=1, maxval=1440, title="Timeframe 1", group=Timeframe_1_Group, inline="T1")
TF_1_Period = input.string(defval="Hour", title="", options=["Minute", "Hour", "Day", "Week", "Month"], group=Timeframe_1_Group, inline="T1", tooltip=Timeframe_Tooltip)
TF_1_Swing_Length = input.int(defval = 7, title = "Swing Length", minval = 1, group = Timeframe_1_Group)
TF_1_Line_Type = input.string(defval = "Solid", title = "Border Type", options = ["Solid", "Dashed", "Dotted"], group = Timeframe_1_Group)
TF_1_Line_Width = input.int(defval = 2, title = "Line Width", group = Timeframe_1_Group)
TF_1_Text_Size = input.string(defval = "Small", title = "Text Size", options = ["Normal", "Tiny", "Small", "Large", "Huge", "Auto"], group = Timeframe_1_Group)
TF_1_Bul_Bos_Col = input.color(defval = color.green, title = "Bullish Bos/Mss Color", group = Timeframe_1_Group, inline = "TF 1 Color")
TF_1_Bear_Bos_Col = input.color(defval = color.red, title = "Bearish Bos/Mss Color", group = Timeframe_1_Group, inline = "TF 1 Color")
TF_1_Bul_MS_Col = input.color(defval = color.white, title = "Bullish Text MS Color", group = Timeframe_1_Group, inline = "TF 1 Ms Color")
TF_1_Bear_MS_Col = input.color(defval = color.white, title = "Bearish Text MS Color", group = Timeframe_1_Group, inline = "TF 1 Ms Color")


// Timeframe 2 Settings
TF_2_Use_Bos_Plot = input.bool(defval = true, title = "Show TF 2 BOS Plots", group = Timeframe_2_Group, tooltip = BOS_Plot_Tooltip)
TF_2_Use_MSS_Plot = input.bool(defval = true, title = "Show TF 2 MSS Plots", group = Timeframe_2_Group, tooltip = MSS_Plot_Tooltip)
TF_2_Chart_Feature = input.bool(defval = true, title = "Set Timeframe to Chart", group = Timeframe_2_Group, tooltip = Set_To_Chart_Tooltip)
TF_2_Use_High_Low = input.bool(defval = false, title = "Use High/Low for Bos & Mss", group = Timeframe_2_Group, tooltip = Use_High_Low_Tooltip)
TF_2_Display_Pivots = input.bool(defval = true, title = "Display Market Structure", group = Timeframe_2_Group, tooltip = Display_TF_MS)
TF_2_Display_Timeframe = input.bool(defval = true, title = "Display Timeframe", group = Timeframe_2_Group, tooltip = Display_TF_Pivots)
TF_2_BOS_Alert = input.bool(defval = true, title = "Use TF 2 BOS Alert", group = Timeframe_2_Group, tooltip = BOS_Alert_Tooltip)
TF_2_MSS_Alert = input.bool(defval = true, title = "Use TF 2 MSS Alert", group = Timeframe_2_Group, tooltip = MSS_Alert_Tooltip)
TF_2_Multip = input.int(defval=2, minval=1, maxval=1440, title="Timeframe 2", group=Timeframe_2_Group, inline="T2")
TF_2_Period = input.string(defval="Hour", title="", options=["Minute", "Hour", "Day", "Week", "Month"], group=Timeframe_2_Group, inline="T2", tooltip=Timeframe_Tooltip)
TF_2_Swing_Length = input.int(defval = 7, title = "Swing Length", minval = 1, group = Timeframe_2_Group)
TF_2_Line_Type = input.string(defval = "Dashed", title = "Border Type", options = ["Solid", "Dashed", "Dotted"], group = Timeframe_2_Group)
TF_2_Line_Width = input.int(defval = 1, title = "Line Width", group = Timeframe_2_Group)
TF_2_Text_Size = input.string(defval = "Small", title = "Text Size", options = ["Normal", "Tiny", "Small", "Large", "Huge", "Auto"], group = Timeframe_2_Group)
TF_2_Bul_Bos_Col = input.color(defval = color.green, title = "Bullish Bos/Mss Color", group = Timeframe_2_Group, inline = "TF 2 Color")
TF_2_Bear_Bos_Col = input.color(defval = color.red, title = "Bearish Bos/Mss Color", group = Timeframe_2_Group, inline = "TF 2 Color")
TF_2_Bul_MS_Col = input.color(defval = color.white, title = "Bullish MS Color", group = Timeframe_2_Group, inline = "TF 2 Ms Color")
TF_2_Bear_MS_Col = input.color(defval = color.white, title = "Bearish MS Color", group = Timeframe_2_Group, inline = "TF 2 Ms Color")


// Timeframe 3 Settings
TF_3_Use_Bos_Plot = input.bool(defval = true, title = "Show TF 3 BOS Plots", group = Timeframe_3_Group, tooltip = BOS_Plot_Tooltip)
TF_3_Use_MSS_Plot = input.bool(defval = true, title = "Show TF 3 MSS Plots", group = Timeframe_3_Group, tooltip = MSS_Plot_Tooltip)
TF_3_Chart_Feature = input.bool(defval = false, title = "Set Timeframe to Chart", group = Timeframe_3_Group, tooltip = Set_To_Chart_Tooltip)
TF_3_Use_High_Low = input.bool(defval = false, title = "Use High/Low for Bos & Mss", group = Timeframe_3_Group, tooltip = Use_High_Low_Tooltip)
TF_3_Display_Pivots = input.bool(defval = false, title = "Display Market Structure", group = Timeframe_3_Group, tooltip = Display_TF_MS)
TF_3_Display_Timeframe = input.bool(defval = false, title = "Display Timeframe", group = Timeframe_3_Group, tooltip = Display_TF_Pivots)
TF_3_BOS_Alert = input.bool(defval = true, title = "Use TF 3 BOS Alert", group = Timeframe_3_Group, tooltip = BOS_Alert_Tooltip)
TF_3_MSS_Alert = input.bool(defval = true, title = "Use TF 3 MSS Alert", group = Timeframe_3_Group, tooltip = MSS_Alert_Tooltip)
TF_3_Multip = input.int(defval=1, minval=1, maxval=1440, title="Timeframe 3", group=Timeframe_3_Group, inline="T3")
TF_3_Period = input.string(defval="Hour", title="", options=["Minute", "Hour", "Day", "Week", "Month"], group=Timeframe_3_Group, inline="T3", tooltip=Timeframe_Tooltip)
TF_3_Swing_Length = input.int(defval = 7, title = "Swing Length", minval = 1, group = Timeframe_3_Group)
TF_3_Line_Type = input.string(defval = "Dotted", title = "Border Type", options = ["Solid", "Dashed", "Dotted"], group = Timeframe_3_Group)
TF_3_Line_Width = input.int(defval = 1, title = "Line Width", group = Timeframe_3_Group)
TF_3_Text_Size = input.string(defval = "Small", title = "Text Size", options = ["Normal", "Tiny", "Small", "Large", "Huge", "Auto"], group = Timeframe_3_Group)
TF_3_Bul_Bos_Col = input.color(defval = color.green, title = "Bullish Bos/Mss Color", group = Timeframe_3_Group, inline = "TF 3 Color")
TF_3_Bear_Bos_Col = input.color(defval = color.red, title = "Bearish Bos/Mss Color", group = Timeframe_3_Group, inline = "TF 3 Color")
TF_3_Bul_MS_Col = input.color(defval = color.white, title = "Bullish MS Color", group = Timeframe_3_Group, inline = "TF 3 Ms Color")
TF_3_Bear_MS_Col = input.color(defval = color.white, title = "Bearish MS Color", group = Timeframe_3_Group, inline = "TF 3 Ms Color")

// --- SCRIPT 2: LuxAlgo SMC (Renamed Conflicts) ---
//CONSTANTS & STRINGS & INPUTS
LUX_BULLISH_LEG                     = 1
LUX_BEARISH_LEG                     = 0

LUX_BULLISH                         = +1
LUX_BEARISH                         = -1

LUX_GREEN                           = #089981
LUX_RED                             = #F23645
LUX_BLUE                            = #2157f3
LUX_GRAY                            = #878b94
LUX_MONO_BULLISH                    = #b2b5be
LUX_MONO_BEARISH                    = #5d606b

LUX_HISTORICAL                      = 'Historical'
LUX_PRESENT                         = 'Present'

LUX_COLORED                         = 'Colored'
LUX_MONOCHROME                      = 'Monochrome'

LUX_ALL                             = 'All'
LUX_BOS                             = 'BOS'
LUX_CHOCH                           = 'CHoCH'

LUX_TINY                            = size.tiny
LUX_SMALL                           = size.small
LUX_NORMAL                          = size.normal

LUX_ATR                             = 'Atr'
LUX_RANGE                           = 'Cumulative Mean Range'

LUX_CLOSE                           = 'Close'
LUX_HIGHLOW                         = 'High/Low'

LUX_SOLID                           = 'âŽ¯âŽ¯âŽ¯'
LUX_DASHED                          = '----'
LUX_DOTTED                          = 'Â·Â·Â·Â·'

SMART_GROUP                     = 'Smart Money Concepts'
INTERNAL_GROUP                  = 'Real Time Internal Structure'
SWING_GROUP                     = 'Real Time Swing Structure'
BLOCKS_GROUP                    = 'Order Blocks'
EQUAL_GROUP                     = 'EQH/EQL'
GAPS_GROUP                      = 'Fair Value Gaps'
LEVELS_GROUP                    = 'Highs & Lows MTF'
ZONES_GROUP                     = 'Premium & Discount Zones'

modeTooltip                     = 'Allows to display historical Structure or only the recent ones'
styleTooltip                    = 'Indicator color theme'
showTrendTooltip                = 'Display additional candles with a color reflecting the current trend detected by structure'
showInternalsTooltip            = 'Display internal market structure'
internalFilterConfluenceTooltip = 'Filter non significant internal structure breakouts'
showStructureTooltip            = 'Display swing market Structure'
showSwingsTooltip               = 'Display swing point as labels on the chart'
showHighLowSwingsTooltip        = 'Highlight most recent strong and weak high/low points on the chart'
showInternalOrderBlocksTooltip  = 'Display internal order blocks on the chart\n\nNumber of internal order blocks to display on the chart'
showSwingOrderBlocksTooltip     = 'Display swing order blocks on the chart\n\nNumber of internal swing blocks to display on the chart'
orderBlockFilterTooltip         = 'Method used to filter out volatile order blocks \n\nIt is recommended to use the cumulative mean range method when a low amount of data is available'
orderBlockMitigationTooltip     = 'Select what values to use for order block mitigation'
showEqualHighsLowsTooltip       = 'Display equal highs and equal lows on the chart'
equalHighsLowsLengthTooltip     = 'Number of bars used to confirm equal highs and equal lows'
equalHighsLowsThresholdTooltip  = 'Sensitivity threshold in a range (0, 1) used for the detection of equal highs & lows\n\nLower values will return fewer but more pertinent results'
showFairValueGapsTooltip        = 'Display fair values gaps on the chart'
fairValueGapsThresholdTooltip   = 'Filter out non significant fair value gaps'
fairValueGapsTimeframeTooltip   = 'Fair value gaps timeframe'
fairValueGapsExtendTooltip      = 'Determine how many bars to extend the Fair Value Gap boxes on chart'
showPremiumDiscountZonesTooltip = 'Display premium, discount, and equilibrium zones on chart'

modeInput                       = input.string( LUX_HISTORICAL, 'Mode',                     group = SMART_GROUP,    tooltip = modeTooltip, options = [LUX_HISTORICAL, LUX_PRESENT])
styleInput                      = input.string( LUX_COLORED,    'Style',                    group = SMART_GROUP,    tooltip = styleTooltip,options = [LUX_COLORED, LUX_MONOCHROME])
showTrendInput                  = input(        false,      'Color Candles',            group = SMART_GROUP,    tooltip = showTrendTooltip)

showInternalsInput              = input(        true,       'Show Internal Structure',  group = INTERNAL_GROUP, tooltip = showInternalsTooltip)
showInternalBullInput           = input.string( LUX_ALL,        'Bullish Structure',        group = INTERNAL_GROUP, inline = 'ibull', options = [LUX_ALL,LUX_BOS,LUX_CHOCH])
internalBullColorInput          = input(        LUX_GREEN,      '',                         group = INTERNAL_GROUP, inline = 'ibull')
showInternalBearInput           = input.string( LUX_ALL,        'Bearish Structure' ,       group = INTERNAL_GROUP, inline = 'ibear', options = [LUX_ALL,LUX_BOS,LUX_CHOCH])
internalBearColorInput          = input(        LUX_RED,        '',                         group = INTERNAL_GROUP, inline = 'ibear')
internalFilterConfluenceInput   = input(        false,      'Confluence Filter',        group = INTERNAL_GROUP, tooltip = internalFilterConfluenceTooltip)
internalStructureSize           = input.string( LUX_TINY,       'Internal Label Size',      group = INTERNAL_GROUP, options = [LUX_TINY,LUX_SMALL,LUX_NORMAL])

showStructureInput              = input(        true,       'Show Swing Structure',     group = SWING_GROUP,    tooltip = showStructureTooltip)
showSwingBullInput              = input.string( LUX_ALL,        'Bullish Structure',        group = SWING_GROUP,    inline = 'bull',    options = [LUX_ALL,LUX_BOS,LUX_CHOCH])
swingBullColorInput             = input(        LUX_GREEN,      '',                         group = SWING_GROUP,    inline = 'bull')
showSwingBearInput              = input.string( LUX_ALL,        'Bearish Structure',        group = SWING_GROUP,    inline = 'bear',    options = [LUX_ALL,LUX_BOS,LUX_CHOCH])
swingBearColorInput             = input(        LUX_RED,        '',                         group = SWING_GROUP,    inline = 'bear')
swingStructureSize              = input.string( LUX_SMALL,      'Swing Label Size',         group = SWING_GROUP,    options = [LUX_TINY,LUX_SMALL,LUX_NORMAL])
showSwingsInput                 = input(        false,      'Show Swings Points',       group = SWING_GROUP,    tooltip = showSwingsTooltip,inline = 'swings')
swingsLengthInput               = input.int(    50,         '',                         group = SWING_GROUP,    minval = 10,                inline = 'swings')
showHighLowSwingsInput          = input(        true,       'Show Strong/Weak High/Low',group = SWING_GROUP,    tooltip = showHighLowSwingsTooltip)

showInternalOrderBlocksInput    = input(        true,       'Internal Order Blocks' ,   group = BLOCKS_GROUP,   tooltip = showInternalOrderBlocksTooltip,   inline = 'iob')
internalOrderBlocksSizeInput    = input.int(    5,          '',                         group = BLOCKS_GROUP,   minval = 1, maxval = 20,                    inline = 'iob')
showSwingOrderBlocksInput       = input(        false,      'Swing Order Blocks',       group = BLOCKS_GROUP,   tooltip = showSwingOrderBlocksTooltip,      inline = 'ob')
swingOrderBlocksSizeInput       = input.int(    5,          '',                         group = BLOCKS_GROUP,   minval = 1, maxval = 20,                    inline = 'ob') 
orderBlockFilterInput           = input.string( 'Atr',      'Order Block Filter',       group = BLOCKS_GROUP,   tooltip = orderBlockFilterTooltip,          options = [LUX_ATR, LUX_RANGE])
orderBlockMitigationInput       = input.string( LUX_HIGHLOW,    'Order Block Mitigation',   group = BLOCKS_GROUP,   tooltip = orderBlockMitigationTooltip,      options = [LUX_CLOSE,LUX_HIGHLOW])
internalBullishOrderBlockColor  = input.color(color.new(#3179f5, 80), 'Internal Bullish OB',    group = BLOCKS_GROUP)
internalBearishOrderBlockColor  = input.color(color.new(#f77c80, 80), 'Internal Bearish OB',    group = BLOCKS_GROUP)
swingBullishOrderBlockColor     = input.color(color.new(#1848cc, 80), 'Bullish OB',             group = BLOCKS_GROUP)
swingBearishOrderBlockColor     = input.color(color.new(#b22833, 80), 'Bearish OB',             group = BLOCKS_GROUP)

showEqualHighsLowsInput         = input(        true,       'Equal High/Low',           group = EQUAL_GROUP,    tooltip = showEqualHighsLowsTooltip)
equalHighsLowsLengthInput       = input.int(    3,          'Bars Confirmation',        group = EQUAL_GROUP,    tooltip = equalHighsLowsLengthTooltip,      minval = 1)
equalHighsLowsThresholdInput    = input.float(  0.1,        'Threshold',                group = EQUAL_GROUP,    tooltip = equalHighsLowsThresholdTooltip,   minval = 0, maxval = 0.5, step = 0.1)
equalHighsLowsSizeInput         = input.string( LUX_TINY,       'Label Size',               group = EQUAL_GROUP,    options = [LUX_TINY,LUX_SMALL,LUX_NORMAL])

showFairValueGapsInput          = input(        false,      'Fair Value Gaps',          group = GAPS_GROUP,     tooltip = showFairValueGapsTooltip)
fairValueGapsThresholdInput     = input(        true,       'Auto Threshold',           group = GAPS_GROUP,     tooltip = fairValueGapsThresholdTooltip)
fairValueGapsTimeframeInput     = input.timeframe('',       'Timeframe',                group = GAPS_GROUP,     tooltip = fairValueGapsTimeframeTooltip)
fairValueGapsBullColorInput     = input.color(color.new(#00ff68, 70), 'Bullish FVG' , group = GAPS_GROUP)
fairValueGapsBearColorInput     = input.color(color.new(#ff0008, 70), 'Bearish FVG' , group = GAPS_GROUP)
fairValueGapsExtendInput        = input.int(    1,          'Extend FVG',               group = GAPS_GROUP,     tooltip = fairValueGapsExtendTooltip,       minval = 0)

showDailyLevelsInput            = input(        false,      'Daily',    group = LEVELS_GROUP,   inline = 'daily')
dailyLevelsStyleInput           = input.string( LUX_SOLID,      '',         group = LEVELS_GROUP,   inline = 'daily',   options = [LUX_SOLID,LUX_DASHED,LUX_DOTTED])
dailyLevelsColorInput           = input(        LUX_BLUE,       '',         group = LEVELS_GROUP,   inline = 'daily')
showWeeklyLevelsInput           = input(        false,      'Weekly',   group = LEVELS_GROUP,   inline = 'weekly')
weeklyLevelsStyleInput          = input.string( LUX_SOLID,      '',         group = LEVELS_GROUP,   inline = 'weekly',  options = [LUX_SOLID,LUX_DASHED,LUX_DOTTED])
weeklyLevelsColorInput          = input(        LUX_BLUE,       '',         group = LEVELS_GROUP,   inline = 'weekly')
showMonthlyLevelsInput          = input(        false,      'Monthly',   group = LEVELS_GROUP,   inline = 'monthly')
monthlyLevelsStyleInput         = input.string( LUX_SOLID,      '',         group = LEVELS_GROUP,   inline = 'monthly', options = [LUX_SOLID,LUX_DASHED,LUX_DOTTED])
monthlyLevelsColorInput         = input(        LUX_BLUE,       '',         group = LEVELS_GROUP,   inline = 'monthly')

showPremiumDiscountZonesInput   = input(        false,      'Premium/Discount Zones',   group = ZONES_GROUP , tooltip = showPremiumDiscountZonesTooltip)
premiumZoneColorInput           = input.color(  LUX_RED,        'Premium Zone',             group = ZONES_GROUP)
equilibriumZoneColorInput       = input.color(  LUX_GRAY,       'Equilibrium Zone',         group = ZONES_GROUP)
discountZoneColorInput          = input.color(  LUX_GREEN,      'Discount Zone',            group = ZONES_GROUP)


// Colors & Constants
c_text = #FFFFFF 
c_bg   = #000000 
c_bull_std = #00FF00
c_bear_std = #FF0000
c_neut = #808080

// =============================================================================
// 2. CORE LOGIC INTEGRATION
// =============================================================================

// --- A. UT BOT ALERTS ---
ut_key = input.int(1, "UT Bot Key Value", group = grp_strat)
ut_period = input.int(10, "UT Bot Period", group = grp_strat)
ut_atr = ta.atr(ut_period)
ut_nLoss = ut_key * ut_atr
ut_src = close

var float ut_stop = 0.0
ut_stop := if ut_src > nz(ut_stop[1], 0) and ut_src[1] > nz(ut_stop[1], 0)
    math.max(nz(ut_stop[1]), ut_src - ut_nLoss)
else if ut_src < nz(ut_stop[1], 0) and ut_src[1] < nz(ut_stop[1], 0)
    math.min(nz(ut_stop[1]), ut_src + ut_nLoss)
else 
    if ut_src > nz(ut_stop[1], 0) 
        ut_src - ut_nLoss 
    else 
        ut_src + ut_nLoss

ut_pos = 0   
ut_pos := if ut_src[1] < nz(ut_stop[1], 0) and ut_src > nz(ut_stop[1], 0)
    1
else if ut_src[1] > nz(ut_stop[1], 0) and ut_src < nz(ut_stop[1], 0)
    -1
else 
    nz(ut_pos[1], 0)

// --- B. SUPERTREND ---
st_factor = input.float(3.0, "Supertrend Factor", group = grp_strat)
st_period = input.int(10, "Supertrend Period", group = grp_strat)
[st_val, st_dir] = ta.supertrend(st_factor, st_period)
is_st_bull = st_dir == -1

// --- C. RSI CUSTOM ---
rsi_val = ta.rsi(rsi_src, rsi_len)

// --- D. SMART MONEY (BASIC - FALLBACK) ---
fvg_bull = low > high[2]
fvg_bear = high < low[2]

// --- E. MULTI-TIMEFRAME ---
get_trend() =>
    e1 = ta.ema(close, 50)
    e2 = ta.ema(close, 200)
    close > e1 and e1 > e2 ? 1 : close < e1 and e1 < e2 ? -1 : 0

t_h1 = request.security(syminfo.tickerid, "60", get_trend())
t_h4 = request.security(syminfo.tickerid, "240", get_trend())

// --- F. ENGULFING CANDLES PATTERN ---
openBarPrevious = open[1]
closeBarPrevious = close[1]
openBarCurrent = open
closeBarCurrent = close

// Bullish Engulfing
bullishEngulfing = openBarCurrent <= closeBarPrevious and openBarCurrent < openBarPrevious and closeBarCurrent > openBarPrevious
// Bearish Engulfing
bearishEngulfing = openBarCurrent >= closeBarPrevious and openBarCurrent > openBarPrevious and closeBarCurrent < openBarPrevious

// --- G. 3 EMA ---
out1 = ta.ema(src_ema1, len_ema1)
out2 = ta.ema(src_ema2, len_ema2)
out3 = ta.ema(src_ema3, len_ema3)


// =============================================================================
// 3. FLUX CHARTS VOLUMIZED ORDER BLOCKS (INTEGRATED ENGINE)
// =============================================================================
const bool DEBUG = false
const int maxBoxesCount = 500
const float overlapThresholdPercentage = 0
const int maxDistanceToLastBar = 1750
const int maxOrderBlocks = 30
OBsEnabled = true

bullishOrderBlocks = flux_zoneCount == "One" ? 1 : flux_zoneCount == "Low" ? 3 : flux_zoneCount == "Medium" ? 5 : 10
bearishOrderBlocks = flux_zoneCount == "One" ? 1 : flux_zoneCount == "Low" ? 3 : flux_zoneCount == "Medium" ? 5 : 10

timeframe1Enabled = true
timeframe1 = ""

extendZonesBy = 15
extendZonesDynamic = true
combinedText = false
volumeBarsPlace = "Left"
mirrorVolumeBars = true

volumeBarsLeftSide = (volumeBarsPlace == "Left")
extendZonesByTime = extendZonesBy * timeframe.in_seconds(timeframe.period) * 1000

flux_atr = ta.atr(10) // Renamed to avoid collision

type orderBlockInfo
    float top
    float bottom
    float obVolume
    string obType
    int startTime
    float bbVolume
    float obLowVolume
    float obHighVolume
    bool breaker
    int breakTime
    string timeframeStr
    bool disabled = false
    string combinedTimeframesStr = na
    bool combined = false

type orderBlock
    orderBlockInfo info
    bool isRendered = false

    box orderBox = na
    box breakerBox = na

    line orderBoxLineTop = na
    line orderBoxLineBottom = na
    line breakerBoxLineTop = na
    line breakerBoxLineBottom = na
    
    box orderBoxText = na
    box orderBoxPositive = na
    box orderBoxNegative = na

    line orderSeperator = na
    line orderTextSeperator = na

createOrderBlock (orderBlockInfo orderBlockInfoF) =>
    orderBlock newOrderBlock = orderBlock.new(orderBlockInfoF)
    newOrderBlock

safeDeleteOrderBlock (orderBlock orderBlockF) =>
    orderBlockF.isRendered := false

    box.delete(orderBlockF.orderBox)
    box.delete(orderBlockF.breakerBox)
    box.delete(orderBlockF.orderBoxText)
    box.delete(orderBlockF.orderBoxPositive)
    box.delete(orderBlockF.orderBoxNegative)

    line.delete(orderBlockF.orderBoxLineTop)
    line.delete(orderBlockF.orderBoxLineBottom)
    line.delete(orderBlockF.breakerBoxLineTop)
    line.delete(orderBlockF.breakerBoxLineBottom)
    line.delete(orderBlockF.orderSeperator)
    line.delete(orderBlockF.orderTextSeperator)

type timeframeInfo
    int index = na
    string timeframeStr = na
    bool isEnabled = false

    orderBlockInfo[] bullishOrderBlocksList = na
    orderBlockInfo[] bearishOrderBlocksList = na

newTimeframeInfo (index, timeframeStr, isEnabled) =>
    newTFInfo = timeframeInfo.new()
    newTFInfo.index := index
    newTFInfo.isEnabled := isEnabled
    newTFInfo.timeframeStr := timeframeStr

    newTFInfo

type obSwing
    int x = na    
    float y = na
    float swingVolume = na
    bool crossed = false

var timeframeInfo[] timeframeInfos = array.from(newTimeframeInfo(1, timeframe1, timeframe1Enabled))
var bullishOrderBlocksList = array.new<orderBlockInfo>(0)
var bearishOrderBlocksList = array.new<orderBlockInfo>(0)

var allOrderBlocksList = array.new<orderBlock>(0)

moveLine(_line, _x, _y, _x2) =>
    line.set_xy1(_line, _x,  _y)
    line.set_xy2(_line, _x2, _y)

moveBox (_box, _topLeftX, _topLeftY, _bottomRightX, _bottomRightY) =>
    box.set_lefttop(_box, _topLeftX, _topLeftY)
    box.set_rightbottom(_box, _bottomRightX, _bottomRightY)

isTimeframeLower (timeframe1F, timeframe2F) =>
    timeframe.in_seconds(timeframe1F) < timeframe.in_seconds(timeframe2F)

formatTimeframeString (formatTimeframe) =>
    timeframeF = formatTimeframe == "" ? timeframe.period : formatTimeframe
    
    if str.contains(timeframeF, "D") or str.contains(timeframeF, "W") or str.contains(timeframeF, "S") or str.contains(timeframeF, "M")
        timeframeF
    else
        seconds = timeframe.in_seconds(timeframeF)
        if seconds >= 3600
            hourCount = int(seconds / 3600)
            str.tostring(hourCount) + " Hour" + (hourCount > 1 ? "s" : "")
        else
            timeframeF + " Min"

colorWithTransparency (colorF, transparencyX) =>
    color.new(colorF, color.t(colorF) * transparencyX)

createOBBox (boxColor, transparencyX = 1.0, xlocType = xloc.bar_time) =>
    box.new(na, na, na, na, text_size = size.normal, xloc = xlocType, extend = extend.none, bgcolor = colorWithTransparency(boxColor, transparencyX), text_color = flux_textColor, text_halign = text.align_center, border_color = #00000000)

renderOrderBlock (orderBlock ob) =>
    orderBlockInfo info = ob.info
    ob.isRendered := true
    orderColor = ob.info.obType == "Bull" ? bullOrderBlockColor : bearOrderBlockColor

    if OBsEnabled and (not false or not (false and info.breaker)) and not (not showInvalidated and info.breaker)
        ob.orderBox := createOBBox(orderColor, 1.5)
        if ob.info.combined
            ob.orderBox.set_bgcolor(colorWithTransparency(orderColor, 1.1))
        ob.orderBoxText := createOBBox(color.new(color.white, 100))
        if orderBlockVolumetricInfo
            ob.orderBoxPositive := createOBBox(bullOrderBlockColor)
            ob.orderBoxNegative := createOBBox(bearOrderBlockColor)
            ob.orderSeperator := line.new(na,na,na,na,xloc.bar_time,extend.none,flux_textColor,line.style_dashed,1)
            ob.orderTextSeperator := line.new(na,na,na,na,xloc.bar_time,extend.none,flux_textColor,line.style_solid,1)

        zoneSize = extendZonesDynamic ? na(info.breakTime) ? extendZonesByTime : (info.breakTime - info.startTime) : extendZonesByTime
        if na(info.breakTime)
            zoneSize := (time + 1) - info.startTime

        startX = volumeBarsLeftSide ? info.startTime : info.startTime + zoneSize - zoneSize / 3
        maxEndX = volumeBarsLeftSide ? info.startTime + zoneSize / 3 : info.startTime + zoneSize

        moveBox(ob.orderBox, info.startTime, info.top, info.startTime + zoneSize, info.bottom)
        moveBox(ob.orderBoxText, volumeBarsLeftSide ? maxEndX : info.startTime, info.top, volumeBarsLeftSide ? info.startTime + zoneSize : startX, info.bottom)

        percentage = int((math.min(info.obHighVolume, info.obLowVolume) / math.max(info.obHighVolume, info.obLowVolume)) * 100.0)
        OBText = (na(ob.info.combinedTimeframesStr) ? formatTimeframeString(ob.info.timeframeStr) : ob.info.combinedTimeframesStr) + " OB"
        box.set_text(ob.orderBoxText, (orderBlockVolumetricInfo ? str.tostring(ob.info.obVolume, format.volume) + " (" + str.tostring(percentage) + "%)\n" : "") + (combinedText and ob.info.combined ? "[Combined]\n" : "") + OBText)

        if orderBlockVolumetricInfo
            showHighLowBoxText = false

            curEndXHigh = int(math.ceil((info.obHighVolume / info.obVolume) * (maxEndX - startX) + startX))
            curEndXLow = int(math.ceil((info.obLowVolume / info.obVolume) * (maxEndX - startX) + startX))

            moveBox(ob.orderBoxPositive, mirrorVolumeBars ? startX : curEndXLow, info.top, mirrorVolumeBars ? curEndXHigh : maxEndX, (info.bottom + info.top) / 2)
            box.set_text(ob.orderBoxPositive, showHighLowBoxText ? str.tostring(info.obHighVolume, format.volume) : "")

            moveBox(ob.orderBoxNegative, mirrorVolumeBars ? startX : curEndXHigh, info.bottom, mirrorVolumeBars ? curEndXLow : maxEndX, (info.bottom + info.top) / 2)
            box.set_text(ob.orderBoxNegative, showHighLowBoxText ? str.tostring(info.obLowVolume, format.volume) : "")

            moveLine(ob.orderSeperator, volumeBarsLeftSide ? startX : maxEndX, (info.bottom + info.top) / 2, volumeBarsLeftSide ? maxEndX : startX)

            line.set_xy1(ob.orderTextSeperator, volumeBarsLeftSide ? maxEndX : startX, info.top)
            line.set_xy2(ob.orderTextSeperator, volumeBarsLeftSide ? maxEndX : startX, info.bottom)

findOBSwings(len) =>
    var swingType = 0
    var obSwing top = obSwing.new(na, na)
    var obSwing bottom = obSwing.new(na, na)
    
    upper = ta.highest(len)
    lower = ta.lowest(len)

    swingType := high[len] > upper ? 0 : low[len] < lower ? 1 : swingType

    if swingType == 0 and swingType[1] != 0
        top := obSwing.new(bar_index[len], high[len], volume[len])
    
    if swingType == 1 and swingType[1] != 1
        bottom := obSwing.new(bar_index[len], low[len], volume[len])

    [top, bottom]

findOrderBlocks () =>
    if bar_index > last_bar_index - maxDistanceToLastBar
        [top, btm] = findOBSwings(swingLength)
        useBody = false
        max = useBody ? math.max(close, open) : high
        min = useBody ? math.min(close, open) : low

        // Bullish Order Block
        bullishBreaked = 0

        if bullishOrderBlocksList.size() > 0
            for i = bullishOrderBlocksList.size() - 1 to 0
                currentOB = bullishOrderBlocksList.get(i)
            
                if not currentOB.breaker 
                    if (obEndMethod == "Wick" ? low : math.min(open, close)) < currentOB.bottom
                        currentOB.breaker := true
                        currentOB.breakTime := time
                        currentOB.bbVolume := volume
                else
                    if high > currentOB.top
                        bullishOrderBlocksList.remove(i)
                    else if i < bullishOrderBlocks and top.y < currentOB.top and top.y > currentOB.bottom 
                        bullishBreaked := 1

        if close > top.y and not top.crossed
            top.crossed := true

            boxBtm = max[1]
            boxTop = min[1]
            boxLoc = time[1]

            for i = 1 to (bar_index - top.x) - 1
                boxBtm := math.min(min[i], boxBtm)
                boxTop := boxBtm == min[i] ? max[i] : boxTop
                boxLoc := boxBtm == min[i] ? time[i] : boxLoc

            newOrderBlockInfo = orderBlockInfo.new(boxTop, boxBtm, volume + volume[1] + volume[2], "Bull", boxLoc)
            newOrderBlockInfo.obLowVolume := volume[2]
            newOrderBlockInfo.obHighVolume := volume + volume[1]
            
            obSize = math.abs(newOrderBlockInfo.top - newOrderBlockInfo.bottom)
            if obSize <= flux_atr * maxATRMult
                bullishOrderBlocksList.unshift(newOrderBlockInfo)
                if bullishOrderBlocksList.size() > maxOrderBlocks
                    bullishOrderBlocksList.pop()

        // Bearish Order Block
        bearishBreaked = 0

        if bearishOrderBlocksList.size() > 0
            for i = bearishOrderBlocksList.size() - 1 to 0
                currentOB = bearishOrderBlocksList.get(i)

                if not currentOB.breaker 
                    if (obEndMethod == "Wick" ? high : math.max(open, close)) > currentOB.top
                        currentOB.breaker := true
                        currentOB.breakTime := time
                        currentOB.bbVolume := volume
                else
                    if low < currentOB.bottom
                        bearishOrderBlocksList.remove(i)
                    else if i < bearishOrderBlocks and btm.y > currentOB.bottom and btm.y < currentOB.top 
                        bearishBreaked := 1

        if close < btm.y and not btm.crossed
            btm.crossed := true

            boxBtm = min[1]
            boxTop = max[1]
            boxLoc = time[1]

            for i = 1 to (bar_index - btm.x) - 1
                boxTop := math.max(max[i], boxTop)
                boxBtm := boxTop == max[i] ? min[i] : boxBtm
                boxLoc := boxTop == max[i] ? time[i] : boxLoc

            newOrderBlockInfo = orderBlockInfo.new(boxTop, boxBtm, volume + volume[1] + volume[2], "Bear", boxLoc)
            newOrderBlockInfo.obLowVolume := volume + volume[1]
            newOrderBlockInfo.obHighVolume := volume[2]

            obSize = math.abs(newOrderBlockInfo.top - newOrderBlockInfo.bottom)
            if obSize <= flux_atr * maxATRMult
                bearishOrderBlocksList.unshift(newOrderBlockInfo)
                if bearishOrderBlocksList.size() > maxOrderBlocks
                    bearishOrderBlocksList.pop()
    true

areaOfOB (orderBlockInfo OBInfoF) =>
    float XA1 = OBInfoF.startTime
    float XA2 = na(OBInfoF.breakTime) ? time + 1 : OBInfoF.breakTime
    float YA1 = OBInfoF.top
    float YA2 = OBInfoF.bottom
    float edge1 = math.sqrt((XA2 - XA1) * (XA2 - XA1) + (YA2 - YA2) * (YA2 - YA2))
    float edge2 = math.sqrt((XA2 - XA2) * (XA2 - XA2) + (YA2 - YA1) * (YA2 - YA1))
    float totalArea = edge1 * edge2
    totalArea

doOBsTouch (orderBlockInfo OBInfo1, orderBlockInfo OBInfo2) =>
    float XA1 = OBInfo1.startTime
    float XA2 = na(OBInfo1.breakTime) ? time + 1 : OBInfo1.breakTime
    float YA1 = OBInfo1.top
    float YA2 = OBInfo1.bottom

    float XB1 = OBInfo2.startTime
    float XB2 = na(OBInfo2.breakTime) ? time + 1 : OBInfo2.breakTime
    float YB1 = OBInfo2.top
    float YB2 = OBInfo2.bottom
    float intersectionArea = math.max(0, math.min(XA2, XB2) - math.max(XA1, XB1)) * math.max(0, math.min(YA1, YB1) - math.max(YA2, YB2))
    float unionArea = areaOfOB(OBInfo1) + areaOfOB(OBInfo2) - intersectionArea
    
    float overlapPercentage = (intersectionArea / unionArea) * 100.0

    if overlapPercentage > overlapThresholdPercentage
        true
    else
        false

isOBValid (orderBlockInfo OBInfo) =>
    valid = true
    if OBInfo.disabled
        valid := false
    valid

combineOBsFunc () =>
    if allOrderBlocksList.size() > 0
        lastCombinations = 999
        while lastCombinations > 0
            lastCombinations := 0
            for i = 0 to allOrderBlocksList.size() - 1
                curOB1 = allOrderBlocksList.get(i)
                for j = 0 to allOrderBlocksList.size() - 1
                    curOB2 = allOrderBlocksList.get(j)
                    if i == j
                        continue
                    if not isOBValid(curOB1.info) or not isOBValid(curOB2.info)
                        continue
                    if curOB1.info.obType != curOB2.info.obType
                        continue
                    if doOBsTouch(curOB1.info, curOB2.info)
                        curOB1.info.disabled := true
                        curOB2.info.disabled := true
                        orderBlock newOB = createOrderBlock(orderBlockInfo.new(math.max(curOB1.info.top, curOB2.info.top), math.min(curOB1.info.bottom, curOB2.info.bottom), curOB1.info.obVolume + curOB2.info.obVolume, curOB1.info.obType))
                        newOB.info.startTime := math.min(curOB1.info.startTime, curOB2.info.startTime)
                        newOB.info.breakTime := math.max(nz(curOB1.info.breakTime), nz(curOB2.info.breakTime))
                        newOB.info.breakTime := newOB.info.breakTime == 0 ? na : newOB.info.breakTime
                        newOB.info.timeframeStr := curOB1.info.timeframeStr

                        newOB.info.obVolume := curOB1.info.obVolume + curOB2.info.obVolume
                        newOB.info.obLowVolume := curOB1.info.obLowVolume + curOB2.info.obLowVolume
                        newOB.info.obHighVolume := curOB1.info.obHighVolume + curOB2.info.obHighVolume
                        newOB.info.bbVolume := nz(curOB1.info.bbVolume, 0) + nz(curOB2.info.bbVolume, 0)
                        newOB.info.breaker := curOB1.info.breaker or curOB2.info.breaker
                        
                        newOB.info.combined := true
                        if timeframe.in_seconds(curOB1.info.timeframeStr) != timeframe.in_seconds(curOB2.info.timeframeStr)
                            newOB.info.combinedTimeframesStr := (na(curOB1.info.combinedTimeframesStr) ? formatTimeframeString(curOB1.info.timeframeStr) : curOB1.info.combinedTimeframesStr) + " & " + (na(curOB2.info.combinedTimeframesStr) ? formatTimeframeString(curOB2.info.timeframeStr) : curOB2.info.combinedTimeframesStr)
                        allOrderBlocksList.unshift(newOB)
                        lastCombinations += 1

reqSeq (timeframeStr, bullishList, bearishList) =>
    [bullishOrderBlocksListF, bearishOrderBlocksListF] = request.security(syminfo.tickerid, timeframeStr, [bullishList, bearishList])
    [bullishOrderBlocksListF, bearishOrderBlocksListF]

getTFData (timeframeInfo timeframeInfoF, timeframeStr) =>
    if not isTimeframeLower(timeframeInfoF.timeframeStr, timeframe.period) and timeframeInfoF.isEnabled
        [bullishOrderBlocksListF, bearishOrderBlocksListF] = reqSeq(timeframeStr, bullishOrderBlocksList, bearishOrderBlocksList)
        [bullishOrderBlocksListF, bearishOrderBlocksListF]
    else
        [na, na]

handleTimeframeInfo (timeframeInfo timeframeInfoF, bullishOrderBlocksListF, bearishOrderBlocksListF) =>
    if not isTimeframeLower(timeframeInfoF.timeframeStr, timeframe.period) and timeframeInfoF.isEnabled
        timeframeInfoF.bullishOrderBlocksList := bullishOrderBlocksListF
        timeframeInfoF.bearishOrderBlocksList := bearishOrderBlocksListF

handleOrderBlocksFinal () =>
    if DEBUG
        log.info("Bullish OB Count " + str.tostring(bullishOrderBlocksList.size()))
        log.info("Bearish OB Count " + str.tostring(bearishOrderBlocksList.size()))

    if allOrderBlocksList.size () > 0
        for i = 0 to allOrderBlocksList.size() - 1
            safeDeleteOrderBlock(allOrderBlocksList.get(i))
    allOrderBlocksList.clear()    

    for i = 0 to timeframeInfos.size() - 1
        curTimeframe = timeframeInfos.get(i)
        if not curTimeframe.isEnabled
            continue
        if curTimeframe.bullishOrderBlocksList.size() > 0
            for j = 0 to math.min(curTimeframe.bullishOrderBlocksList.size() - 1, bullishOrderBlocks - 1)
                orderBlockInfoF = curTimeframe.bullishOrderBlocksList.get(j)
                orderBlockInfoF.timeframeStr := curTimeframe.timeframeStr
                allOrderBlocksList.unshift(createOrderBlock(orderBlockInfo.copy(orderBlockInfoF)))

        if curTimeframe.bearishOrderBlocksList.size() > 0
            for j = 0 to math.min(curTimeframe.bearishOrderBlocksList.size() - 1, bearishOrderBlocks - 1)
                orderBlockInfoF = curTimeframe.bearishOrderBlocksList.get(j)
                orderBlockInfoF.timeframeStr := curTimeframe.timeframeStr
                allOrderBlocksList.unshift(createOrderBlock(orderBlockInfo.copy(orderBlockInfoF)))

    if combineOBs
        combineOBsFunc()    

    if allOrderBlocksList.size() > 0
        for i = 0 to allOrderBlocksList.size() - 1
            curOB = allOrderBlocksList.get(i)
            if isOBValid(curOB.info)
                renderOrderBlock(curOB)

findOrderBlocks()

[bullishOrderBlocksListTimeframe1, bearishOrderBlocksListTimeframe1] = getTFData(timeframeInfos.get(0), timeframe1)

if barstate.isconfirmed
    handleTimeframeInfo(timeframeInfos.get(0), bullishOrderBlocksListTimeframe1, bearishOrderBlocksListTimeframe1)
    handleOrderBlocksFinal()

// --- SCRIPT 1 LOGIC: MTF BOS & MSS ---

// General functions
// Getting the line type from the user.
Line_Type_Control(Type) =>
    Line_Functionality = switch Type
        "Solid" => line.style_solid
        "Dashed" => line.style_dashed
        "Dotted" => line.style_dotted
    
    Line_Functionality

// Text size from the user
Text_Size_Switch(Text_Size) =>
    Text_Type = switch Text_Size
        "Normal" => size.normal
        "Tiny" => size.tiny
        "Small" => size.small
        "Large" => size.large
        "Huge" => size.huge
        "Auto" => size.auto
    Text_Type

// Timeframe functionality
// Timeframe for security functions
TF(TF_Period, TF_Multip) => 
    switch TF_Period 
        "Minute" => str.tostring(TF_Multip)
        "Hour"   => str.tostring(TF_Multip*60)
        "Day"    => str.tostring(TF_Multip) + "D"
        "Week"   => str.tostring(TF_Multip) + "W"
        "Month"  => str.tostring(TF_Multip) + "M"
        => timeframe.period

// Timeframe shortcut form
TF_Display(Chart_as_Timeframe, TF_Period, TF_Multip) =>
    if Chart_as_Timeframe == false
        switch TF_Period
            "Minute" => str.tostring(TF_Multip)  + "Min"
            "Hour"   => str.tostring(TF_Multip)  + "H"
            "Day"    => str.tostring(TF_Multip)  + "D"
            "Week"   => str.tostring(TF_Multip)  + "W"
            "Month"  => str.tostring(TF_Multip)  + "M"
    
    else if Chart_as_Timeframe == true
        switch 
            timeframe.isminutes and  timeframe.multiplier % 60 != 0 
                                 => str.tostring(timeframe.multiplier)    + "Min"
                                 
            timeframe.isminutes and  timeframe.multiplier % 60 == 0 
                                 => str.tostring(timeframe.multiplier/60) + "H"
                                 
            timeframe.isdaily    => str.tostring(timeframe.multiplier)    + "D"
            timeframe.isweekly   => str.tostring(timeframe.multiplier)    + "W"
            timeframe.ismonthly  => str.tostring(timeframe.multiplier)    + "M"

MTF_MS_Display(Chart_as_Timeframe, TF_Period, TF_Multip, Swing_Length) =>
    if Chart_as_Timeframe == true
        Swing_Length
    else
        switch
            TF_Period == "Month" and timeframe.isminutes and timeframe.multiplier % 60 == 0 and 
              (24*5*5/((TF_Multip * 1440*5*5)/timeframe.multiplier)) * 60 == timeframe.multiplier => ((TF_Multip * 1440)*5*5/ timeframe.multiplier)*Swing_Length

            TF_Period == "Month" and timeframe.isweekly and 
              (5/((TF_Multip * 1440 * 5)/timeframe.multiplier)) * 1440 == timeframe.multiplier => ((TF_Multip * 1440)*5/ 1440)*Swing_Length

            TF_Period == "Month" and timeframe.isdaily and 
              (5*5/((TF_Multip * 1440 * 5*5)/timeframe.multiplier)) * 1440 == timeframe.multiplier => ((TF_Multip * 1440)*5*5/ 1440)*Swing_Length
            
            timeframe.ismonthly  and timeframe.multiplier == TF_Multip and 
              TF_Period == "Month" => Swing_Length

            TF_Period == "Week" and timeframe.isminutes and timeframe.multiplier % 60 == 0 and 
              (24*5/((TF_Multip * 1440*5)/timeframe.multiplier)) * 60 == timeframe.multiplier => ((TF_Multip * 1440)*5/ timeframe.multiplier)*Swing_Length

            TF_Period == "Week" and timeframe.isdaily and 
              (5/((TF_Multip * 1440 * 5)/timeframe.multiplier)) * 1440 == timeframe.multiplier => ((TF_Multip * 1440)*5/ 1440)*Swing_Length
            
            timeframe.isweekly  and timeframe.multiplier == TF_Multip and 
              TF_Period == "Week" => Swing_Length

            TF_Period == "Day" and timeframe.isminutes and timeframe.multiplier % 60 == 0 and 
              (24/((TF_Multip * 1440)/timeframe.multiplier)) * 60 == timeframe.multiplier => (TF_Multip * 1440/ timeframe.multiplier)*Swing_Length

            timeframe.isdaily  and timeframe.multiplier == TF_Multip and 
              TF_Period == "Day" => Swing_Length
            
            timeframe.isminutes and timeframe.multiplier % 60 != 0 and 
              TF_Period == "Minute" and TF_Multip == timeframe.multiplier => Swing_Length
            
            timeframe.isminutes and timeframe.multiplier % 60 != 0 and 
              TF_Period == "Minute" and TF_Multip != timeframe.multiplier => ((TF_Multip/60) * 60/timeframe.multiplier)*Swing_Length

            timeframe.isminutes and timeframe.multiplier % 60 != 0 and 
              TF_Period == "Hour" and TF_Multip != timeframe.multiplier => ((TF_Multip * 60 /60) * 60/timeframe.multiplier)*Swing_Length

            timeframe.isminutes and timeframe.multiplier % 60 != 0 and 
              TF_Period == "Hour" and TF_Multip == timeframe.multiplier and timeframe.multiplier * 60 == 60 => ((TF_Multip * 60 /60) * 60/timeframe.multiplier)*Swing_Length

            timeframe.isminutes and timeframe.multiplier % 60 != 0 and 
              TF_Period == "Day" and TF_Multip != timeframe.multiplier => ((TF_Multip * 1440 /60) * 60/timeframe.multiplier)*Swing_Length
            
            timeframe.isminutes and timeframe.multiplier % 60 == 0 and 
              TF_Period == "Hour" and TF_Multip * 60 == timeframe.multiplier => Swing_Length

            timeframe.isminutes and timeframe.multiplier % 60 == 0 and 
              TF_Period == "Hour" and TF_Multip * 60 != timeframe.multiplier => (TF_Multip * 60/timeframe.multiplier)*Swing_Length

HTF_Structure_Control(Chart_as_Timeframe, TF_Period, TF_Multip) =>
    if Chart_as_Timeframe == true
        true
    else if Show_Only_On_Lower_Timeframes == false
        true
    else 
        switch
            TF_Period == "Minute" and TF_Multip < timeframe.multiplier and timeframe.isminutes
              => false
            TF_Period == "Minute" and TF_Multip >= timeframe.multiplier and timeframe.isminutes
              => true
            TF_Period == "Minute" and timeframe.isdaily 
              => false
            TF_Period == "Minute" and timeframe.isweekly 
              => false
            TF_Period == "Minute" and timeframe.ismonthly 
              => false
            TF_Period == "Hour" and TF_Multip * 60 < timeframe.multiplier and timeframe.isminutes 
              => false
            TF_Period == "Hour" and TF_Multip * 60 >= timeframe.multiplier and timeframe.isminutes
              => true
            TF_Period == "Hour" and timeframe.isdaily 
              => false
            TF_Period == "Hour" and timeframe.isweekly 
              => false
            TF_Period == "Hour" and timeframe.ismonthly 
              => false
            TF_Period == "Day" and timeframe.isdaily or timeframe.isminutes 
              => true
            TF_Period == "Week" and timeframe.isweekly or timeframe.isdaily or timeframe.isminutes 
              => true
            TF_Period == "Month" and timeframe.ismonthly or timeframe.isweekly or timeframe.isdaily or timeframe.isminutes 
              => true
    
// Calculating the Mtf BOS and MSS
// Getting the high and low values
[TF_1_SH, TF_1_SL] = request.security(symbol = syminfo.tickerid, timeframe = (TF_1_Chart_Feature ? timeframe.period : TF(TF_1_Period, TF_1_Multip))
  , expression = [ta.pivothigh(high, TF_1_Swing_Length, TF_1_Swing_Length), ta.pivotlow(low, TF_1_Swing_Length, TF_1_Swing_Length)], gaps = barmerge.gaps_on)
[TF_2_SH, TF_2_SL] = request.security(symbol = syminfo.tickerid, timeframe = (TF_2_Chart_Feature ? timeframe.period : TF(TF_2_Period, TF_2_Multip))
  , expression = [ta.pivothigh(high, TF_2_Swing_Length, TF_2_Swing_Length), ta.pivotlow(low, TF_2_Swing_Length, TF_2_Swing_Length)], gaps = barmerge.gaps_on)
[TF_3_SH, TF_3_SL] = request.security(symbol = syminfo.tickerid, timeframe = (TF_3_Chart_Feature ? timeframe.period : TF(TF_3_Period, TF_3_Multip))
  , expression = [ta.pivothigh(high, TF_3_Swing_Length, TF_3_Swing_Length), ta.pivotlow(low, TF_3_Swing_Length, TF_3_Swing_Length)], gaps = barmerge.gaps_on)


Count_Candles_For_Structure(Direction, Condition) =>
    var int High_Count = 0
    var int Low_Count = 0

    if Direction == "Bullish"
        for i = 0 to Condition
            High_Count := i                 
        High_Count
    else if Direction == "Bearish"
        for i = 0 to Condition
            Low_Count := i 
        Low_Count


Market_Structure(TF_SH, TF_SL, Swing_Length, Chart_as_Timeframe, TF_Period, TF_Multip
  , Line_Type, Line_Width, Display_Timeframe, Display_Structure, Bul_Bos_Col, Bear_Bos_Col
  , Bul_Ms_Col, Bear_Ms_Col, TF_Text_Size, Use_High_Low, Use_BOS_Alert, Use_MSS_Alert
  , Use_Bos_Plot, Use_MSS_Plot) => 
    // Variables to identify HH, HL, LH, LL
    var float TF_Prev_High = na
    var float TF_Prev_Low = na
    TF_Prev_High_Time = 0
    TF_Prev_Low_Time = 0
    High_Count = 0
    Low_Count = 0

    //Tracking whether previous levels have been broken
    var bool TF_High_Present = false
    var bool TF_Low_Present = false
    
    //Tracking prev breakout
    var int Prev_Breakout_Type = 0

    //Varibales for generating BOS and CHOCH
    bool High_Broken = false
    bool Low_Broken = false
    End_High_Time = 0
    End_Low_Time = 0
    
    // Variables for Market Structure
    bool HH = false
    bool LH = false
    bool HL = false
    bool LL = false

    TF_High_Close_Price = request.security(symbol = syminfo.tickerid, timeframe = (Chart_as_Timeframe ? timeframe.period : TF(TF_Period, TF_Multip)), expression = (Use_High_Low ? high : close))
    TF_Low_Close_Price = request.security(symbol = syminfo.tickerid, timeframe = (Chart_as_Timeframe ? timeframe.period : TF(TF_Period, TF_Multip)), expression = (Use_High_Low ? low : close)) 

    if not na(TF_SH)
        if TF_SH >= TF_Prev_High
            HH := true 
        else
            LH := true
        TF_Prev_High := TF_SH
        TF_Prev_High_Time := TF_Prev_High != TF_Prev_High[1] ? time[MTF_MS_Display(Chart_as_Timeframe, TF_Period, TF_Multip, Swing_Length)] : TF_Prev_High_Time[1]
        TF_High_Present := true

    if not na(TF_SL)
        if TF_SL >= TF_Prev_Low
            HL := true
        else
            LL := true
        TF_Prev_Low := TF_SL
        TF_Prev_Low_Time := TF_Prev_Low != TF_Prev_Low[1] ? time[MTF_MS_Display(Chart_as_Timeframe, TF_Period, TF_Multip, Swing_Length)] : TF_Prev_Low_Time[1]
        TF_Low_Present := true


    if TF_High_Close_Price > TF_Prev_High and TF_High_Present
        High_Broken := true
        TF_High_Present := false
        End_High_Time := time
        
    if TF_Low_Close_Price < TF_Prev_Low and TF_Low_Present
        Low_Broken := true
        TF_Low_Present := false
        End_Low_Time := time

    // Displaying Swing Levels
    if HH and Display_Timeframe and Display_Structure and not Hide_All_MS
        label.new(TF_Prev_High_Time, TF_Prev_High, "HH \n" + TF_Display(Chart_as_Timeframe, TF_Period, TF_Multip)
          , xloc = xloc.bar_time, color=Transparent_Color, style=label.style_label_down, textcolor=Bul_Ms_Col, size = Text_Size_Switch(TF_Text_Size))
    if HL and Display_Timeframe and Display_Structure and not Hide_All_MS
        label.new(TF_Prev_Low_Time, TF_Prev_Low, "HL \n" + TF_Display(Chart_as_Timeframe, TF_Period, TF_Multip)
          , xloc = xloc.bar_time, color=Transparent_Color, style=label.style_label_up, textcolor=Bul_Ms_Col, size = Text_Size_Switch(TF_Text_Size))
    if LH and Display_Timeframe and Display_Structure and not Hide_All_MS
        label.new(TF_Prev_High_Time, TF_Prev_High, "LH \n" + TF_Display(Chart_as_Timeframe, TF_Period, TF_Multip)
          , xloc = xloc.bar_time, color=Transparent_Color, style=label.style_label_down, textcolor=Bear_Ms_Col, size = Text_Size_Switch(TF_Text_Size))
    if LL and Display_Timeframe and Display_Structure and not Hide_All_MS
        label.new(TF_Prev_Low_Time, TF_Prev_Low, "LL \n" + TF_Display(Chart_as_Timeframe, TF_Period, TF_Multip)
          , xloc = xloc.bar_time, color=Transparent_Color, style=label.style_label_up, textcolor=Bear_Ms_Col, size = Text_Size_Switch(TF_Text_Size)) 

    High_Count := ta.barssince(HH == true or LH == true) + MTF_MS_Display(Chart_as_Timeframe, TF_Period, TF_Multip, Swing_Length)
    Low_Count := ta.barssince(HL == true or LL == true) + MTF_MS_Display(Chart_as_Timeframe, TF_Period, TF_Multip, Swing_Length)

    High_Count_Function = Count_Candles_For_Structure("Bullish", High_Count)
    Low_Count_Function = Count_Candles_For_Structure("Bearish", Low_Count)

    //Generating the BOS Lines
    if High_Broken and Display_Timeframe and not Hide_All_Breaks and HTF_Structure_Control(Chart_as_Timeframe, TF_Period, TF_Multip)
        if Prev_Breakout_Type == 1 and Use_Bos_Plot
            line.new(x1 = time[High_Count_Function] , y1 = TF_Prev_High, x2 =End_High_Time , y2 = TF_Prev_High
              , xloc = xloc.bar_time, color = Bul_Bos_Col, style=Line_Type_Control(Line_Type), width= Line_Width)
            label.new(x = time[High_Count_Function/2], y = TF_Prev_High
              , xloc = xloc.bar_time, text = 'BOS \n' + TF_Display(Chart_as_Timeframe, TF_Period, TF_Multip)
              , color=Transparent_Color, style=label.style_label_down, textcolor=Bul_Bos_Col, size = Text_Size_Switch(TF_Text_Size))
        else if Prev_Breakout_Type == -1 and Use_MSS_Plot
            line.new(x1 = time[High_Count_Function] , y1 = TF_Prev_High, x2 =End_High_Time , y2 = TF_Prev_High
              , xloc = xloc.bar_time, color = Bul_Bos_Col, style=Line_Type_Control(Line_Type), width= Line_Width)
            label.new(x = time[High_Count_Function/2], y = TF_Prev_High
              , xloc = xloc.bar_time, text = 'MSS \n' + TF_Display(Chart_as_Timeframe, TF_Period, TF_Multip)
              , color=Transparent_Color, style=label.style_label_down, textcolor=Bul_Bos_Col, size = Text_Size_Switch(TF_Text_Size))

        if Prev_Breakout_Type == -1 and Use_MSS_Alert
            alert(message = "New bullish MSS formed on " + TF_Display(Chart_as_Timeframe, TF_Period, TF_Multip), freq = alert.freq_once_per_bar_close)
        else if Prev_Breakout_Type == 1 and Use_BOS_Alert
            alert(message = "New bullish BOS formed on " + TF_Display(Chart_as_Timeframe, TF_Period, TF_Multip), freq = alert.freq_once_per_bar_close)

        Prev_Breakout_Type := 1
       
    if Low_Broken and Display_Timeframe and not Hide_All_Breaks and HTF_Structure_Control(Chart_as_Timeframe, TF_Period, TF_Multip)
        if Prev_Breakout_Type == -1 and Use_Bos_Plot
            line.new(x1 = time[Low_Count_Function] , y1 = TF_Prev_Low, x2 = End_Low_Time, y2 = TF_Prev_Low
              , xloc = xloc.bar_time, color= Bear_Bos_Col, style=Line_Type_Control(Line_Type), width= Line_Width)
            label.new(x = time[Low_Count_Function/2], y = TF_Prev_Low
              , xloc = xloc.bar_time, text = 'BOS \n' + TF_Display(Chart_as_Timeframe, TF_Period, TF_Multip)
              , color=Transparent_Color, textcolor=Bear_Bos_Col, style=label.style_label_up, size = Text_Size_Switch(TF_Text_Size))
        else if Prev_Breakout_Type == 1 and Use_MSS_Plot
            line.new(x1 = time[Low_Count_Function] , y1 = TF_Prev_Low, x2 = End_Low_Time, y2 = TF_Prev_Low
              , xloc = xloc.bar_time, color= Bear_Bos_Col, style=Line_Type_Control(Line_Type), width= Line_Width)
            label.new(x = time[Low_Count_Function/2], y = TF_Prev_Low
              , xloc = xloc.bar_time, text = 'MSS \n' + TF_Display(Chart_as_Timeframe, TF_Period, TF_Multip)
              , color=Transparent_Color, textcolor=Bear_Bos_Col, style=label.style_label_up, size = Text_Size_Switch(TF_Text_Size))          

        if Prev_Breakout_Type == 1 and Use_MSS_Alert
            alert(message = "New bearish MSS formed on " + TF_Display(Chart_as_Timeframe, TF_Period, TF_Multip), freq = alert.freq_once_per_bar_close)
        else if Prev_Breakout_Type == -1 and Use_BOS_Alert
            alert(message = "New bearish BOS formed on " + TF_Display(Chart_as_Timeframe, TF_Period, TF_Multip), freq = alert.freq_once_per_bar_close)
        
        Prev_Breakout_Type := -1

// Calling functions
Market_Structure(TF_1_SH, TF_1_SL, TF_1_Swing_Length, TF_1_Chart_Feature, TF_1_Period, TF_1_Multip, TF_1_Line_Type, TF_1_Line_Width
  , TF_1_Display_Timeframe, TF_1_Display_Pivots, TF_1_Bul_Bos_Col, TF_1_Bear_Bos_Col, TF_1_Bul_MS_Col, TF_1_Bear_MS_Col, TF_1_Text_Size
  , TF_1_Use_High_Low, TF_1_BOS_Alert, TF_1_MSS_Alert
  , TF_1_Use_Bos_Plot, TF_1_Use_MSS_Plot)
Market_Structure(TF_2_SH, TF_2_SL, TF_2_Swing_Length, TF_2_Chart_Feature, TF_2_Period, TF_2_Multip, TF_2_Line_Type, TF_2_Line_Width
  , TF_2_Display_Timeframe, TF_2_Display_Pivots, TF_2_Bul_Bos_Col, TF_2_Bear_Bos_Col, TF_2_Bul_MS_Col, TF_2_Bear_MS_Col, TF_2_Text_Size
  , TF_2_Use_High_Low, TF_2_BOS_Alert, TF_2_MSS_Alert
  , TF_2_Use_Bos_Plot, TF_2_Use_MSS_Plot)
Market_Structure(TF_3_SH, TF_3_SL, TF_3_Swing_Length, TF_3_Chart_Feature, TF_3_Period, TF_3_Multip, TF_3_Line_Type, TF_3_Line_Width
  , TF_3_Display_Timeframe, TF_3_Display_Pivots, TF_3_Bul_Bos_Col, TF_3_Bear_Bos_Col, TF_3_Bul_MS_Col, TF_3_Bear_MS_Col, TF_3_Text_Size
  , TF_3_Use_High_Low, TF_3_BOS_Alert, TF_3_MSS_Alert
  , TF_3_Use_Bos_Plot, TF_3_Use_MSS_Plot)

// --- SCRIPT 2 LOGIC: LuxAlgo SMC (Renamed Types & Logic) ---

//DATA STRUCTURES & VARIABLES
// Renamed types to avoid conflicts (added 'lux')
type luxAlerts
    bool internalBullishBOS         = false
    bool internalBearishBOS         = false
    bool internalBullishCHoCH       = false
    bool internalBearishCHoCH       = false
    bool swingBullishBOS            = false
    bool swingBearishBOS            = false
    bool swingBullishCHoCH          = false
    bool swingBearishCHoCH          = false
    bool internalBullishOrderBlock  = false
    bool internalBearishOrderBlock  = false
    bool swingBullishOrderBlock     = false
    bool swingBearishOrderBlock     = false
    bool equalHighs                 = false
    bool equalLows                  = false
    bool bullishFairValueGap        = false
    bool bearishFairValueGap        = false

type luxTrailingExtremes
    float top
    float bottom
    int barTime
    int barIndex
    int lastTopTime
    int lastBottomTime

type luxFairValueGap
    float top
    float bottom
    int bias
    box topBox
    box bottomBox

type luxTrend
    int bias    

type luxEqualDisplay
    line l_ine      = na
    label l_abel    = na

type luxPivot
    float currentLevel
    float lastLevel
    bool crossed
    int barTime     = time
    int barIndex    = bar_index

type luxOrderBlock
    float barHigh
    float barLow
    int barTime    
    int bias

var luxPivot luxSwingHigh                 = luxPivot.new(na,na,false)
var luxPivot luxSwingLow                  = luxPivot.new(na,na,false)
var luxPivot luxInternalHigh              = luxPivot.new(na,na,false)
var luxPivot luxInternalLow               = luxPivot.new(na,na,false)
var luxPivot luxEqualHigh                 = luxPivot.new(na,na,false)
var luxPivot luxEqualLow                  = luxPivot.new(na,na,false)
var luxTrend luxSwingTrend                = luxTrend.new(0)
var luxTrend luxInternalTrend             = luxTrend.new(0)
var luxEqualDisplay luxEqualHighDisplay   = luxEqualDisplay.new()
var luxEqualDisplay luxEqualLowDisplay    = luxEqualDisplay.new()
var array<luxFairValueGap> luxFairValueGaps = array.new<luxFairValueGap>()
var array<float> luxParsedHighs        = array.new<float>()
var array<float> luxParsedLows         = array.new<float>()
var array<float> luxHighs              = array.new<float>()
var array<float> luxLows               = array.new<float>()
var array<int> luxTimes                = array.new<int>()
var luxTrailingExtremes luxTrailing       = luxTrailingExtremes.new()
var array<luxOrderBlock> luxSwingOrderBlocks      = array.new<luxOrderBlock>()
var array<luxOrderBlock> luxInternalOrderBlocks   = array.new<luxOrderBlock>()
var array<box> luxSwingOrderBlocksBoxes        = array.new<box>()
var array<box> luxInternalOrderBlocksBoxes     = array.new<box>()
var swingBullishColor               = styleInput == LUX_MONOCHROME ? LUX_MONO_BULLISH : swingBullColorInput
var swingBearishColor               = styleInput == LUX_MONOCHROME ? LUX_MONO_BEARISH : swingBearColorInput
var fairValueGapBullishColor        = styleInput == LUX_MONOCHROME ? color.new(LUX_MONO_BULLISH,70) : fairValueGapsBullColorInput
var fairValueGapBearishColor        = styleInput == LUX_MONOCHROME ? color.new(LUX_MONO_BEARISH,70) : fairValueGapsBearColorInput
var luxPremiumZoneColor                = styleInput == LUX_MONOCHROME ? LUX_MONO_BEARISH : premiumZoneColorInput
var luxDiscountZoneColor               = styleInput == LUX_MONOCHROME ? LUX_MONO_BULLISH : discountZoneColorInput 
varip int luxCurrentBarIndex           = bar_index
varip int luxLastBarIndex              = bar_index
luxAlerts luxCurrentAlerts                = luxAlerts.new()
var luxInitialTime                     = time

if barstate.isfirst
    if showSwingOrderBlocksInput
        for index = 1 to swingOrderBlocksSizeInput
            luxSwingOrderBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time,extend = extend.right))
    if showInternalOrderBlocksInput
        for index = 1 to internalOrderBlocksSizeInput
            luxInternalOrderBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time,extend = extend.right))

bearishOrderBlockMitigationSource   = orderBlockMitigationInput == LUX_CLOSE ? close : high
bullishOrderBlockMitigationSource   = orderBlockMitigationInput == LUX_CLOSE ? close : low
atrMeasure                          = ta.atr(200)
volatilityMeasure                   = orderBlockFilterInput == LUX_ATR ? atrMeasure : ta.cum(ta.tr)/bar_index
highVolatilityBar                   = (high - low) >= (2 * volatilityMeasure)
parsedHigh                          = highVolatilityBar ? low : high
parsedLow                           = highVolatilityBar ? high : low

luxParsedHighs.push(parsedHigh)
luxParsedLows.push(parsedLow)
luxHighs.push(high)
luxLows.push(low)
luxTimes.push(time)

//USER-DEFINED FUNCTIONS
luxLeg(int size) =>
    var leg     = 0    
    newLegHigh  = high[size] > ta.highest( size)
    newLegLow   = low[size]  < ta.lowest(  size)
    
    if newLegHigh
        leg := LUX_BEARISH_LEG
    else if newLegLow
        leg := LUX_BULLISH_LEG
    leg

luxStartOfNewLeg(int leg)      => ta.change(leg) != 0
luxStartOfBearishLeg(int leg)  => ta.change(leg) == -1
luxStartOfBullishLeg(int leg)  => ta.change(leg) == +1

luxDrawLabel(int labelTime, float labelPrice, string tag, color labelColor, string labelStyle) =>    
    var label l_abel = na

    if modeInput == LUX_PRESENT
        l_abel.delete()

    l_abel := label.new(chart.point.new(labelTime,na,labelPrice),tag,xloc.bar_time,color=color(na),textcolor=labelColor,style = labelStyle,size = size.small)

luxDrawEqualHighLow(luxPivot p_ivot, float level, int size, bool equalHigh) =>
    luxEqualDisplay e_qualDisplay = equalHigh ? luxEqualHighDisplay : luxEqualLowDisplay
    
    string tag          = 'EQL'
    color equalColor    = swingBullishColor
    string labelStyle   = label.style_label_up

    if equalHigh
        tag         := 'EQH'
        equalColor  := swingBearishColor
        labelStyle  := label.style_label_down

    if modeInput == LUX_PRESENT
        line.delete(    e_qualDisplay.l_ine)
        label.delete(   e_qualDisplay.l_abel)
        
    e_qualDisplay.l_ine     := line.new(chart.point.new(p_ivot.barTime,na,p_ivot.currentLevel), chart.point.new(time[size],na,level), xloc = xloc.bar_time, color = equalColor, style = line.style_dotted)
    labelPosition           = math.round(0.5*(p_ivot.barIndex + bar_index - size))
    e_qualDisplay.l_abel    := label.new(chart.point.new(na,labelPosition,level), tag, xloc.bar_index, color = color(na), textcolor = equalColor, style = labelStyle, size = equalHighsLowsSizeInput)

luxGetCurrentStructure(int size,bool equalHighLow = false, bool internal = false) =>        
    currentLeg              = luxLeg(size)
    newPivot                = luxStartOfNewLeg(currentLeg)
    pivotLow                = luxStartOfBullishLeg(currentLeg)
    pivotHigh               = luxStartOfBearishLeg(currentLeg)

    if newPivot
        if pivotLow
            luxPivot p_ivot    = equalHighLow ? luxEqualLow : internal ? luxInternalLow : luxSwingLow    

            if equalHighLow and math.abs(p_ivot.currentLevel - low[size]) < equalHighsLowsThresholdInput * atrMeasure                
                luxDrawEqualHighLow(p_ivot, low[size], size, false)
                luxCurrentAlerts.equalLows := true

            p_ivot.lastLevel    := p_ivot.currentLevel
            p_ivot.currentLevel := low[size]
            p_ivot.crossed      := false
            p_ivot.barTime      := time[size]
            p_ivot.barIndex     := bar_index[size]

            if not equalHighLow and not internal
                luxTrailing.bottom         := p_ivot.currentLevel
                luxTrailing.barTime        := p_ivot.barTime
                luxTrailing.barIndex       := p_ivot.barIndex
                luxTrailing.lastBottomTime := p_ivot.barTime

            if showSwingsInput and not internal and not equalHighLow
                luxDrawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel < p_ivot.lastLevel ? 'LL' : 'HL', swingBullishColor, label.style_label_up)            
        else
            luxPivot p_ivot = equalHighLow ? luxEqualHigh : internal ? luxInternalHigh : luxSwingHigh

            if equalHighLow and math.abs(p_ivot.currentLevel - high[size]) < equalHighsLowsThresholdInput * atrMeasure
                luxDrawEqualHighLow(p_ivot,high[size],size,true)
                luxCurrentAlerts.equalHighs := true               

            p_ivot.lastLevel    := p_ivot.currentLevel
            p_ivot.currentLevel := high[size]
            p_ivot.crossed      := false
            p_ivot.barTime      := time[size]
            p_ivot.barIndex     := bar_index[size]

            if not equalHighLow and not internal
                luxTrailing.top            := p_ivot.currentLevel
                luxTrailing.barTime        := p_ivot.barTime
                luxTrailing.barIndex       := p_ivot.barIndex
                luxTrailing.lastTopTime    := p_ivot.barTime

            if showSwingsInput and not internal and not equalHighLow
                luxDrawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel > p_ivot.lastLevel ? 'HH' : 'LH', swingBearishColor, label.style_label_down)
                
luxDrawStructure(luxPivot p_ivot, string tag, color structureColor, string lineStyle, string labelStyle, string labelSize) =>    
    var line l_ine      = line.new(na,na,na,na,xloc = xloc.bar_time)
    var label l_abel    = label.new(na,na)

    if modeInput == LUX_PRESENT
        l_ine.delete()
        l_abel.delete()

    l_ine   := line.new(chart.point.new(p_ivot.barTime,na,p_ivot.currentLevel), chart.point.new(time,na,p_ivot.currentLevel), xloc.bar_time, color=structureColor, style=lineStyle)
    l_abel  := label.new(chart.point.new(na,math.round(0.5*(p_ivot.barIndex+bar_index)),p_ivot.currentLevel), tag, xloc.bar_index, color=color(na), textcolor=structureColor, style=labelStyle, size = labelSize)

luxDeleteOrderBlocks(bool internal = false) =>
    array<luxOrderBlock> orderBlocks = internal ? luxInternalOrderBlocks : luxSwingOrderBlocks

    for [index,eachOrderBlock] in orderBlocks
        bool crossedOderBlock = false
        
        if bearishOrderBlockMitigationSource > eachOrderBlock.barHigh and eachOrderBlock.bias == LUX_BEARISH
            crossedOderBlock := true
            if internal
                luxCurrentAlerts.internalBearishOrderBlock := true
            else
                luxCurrentAlerts.swingBearishOrderBlock    := true
        else if bullishOrderBlockMitigationSource < eachOrderBlock.barLow and eachOrderBlock.bias == LUX_BULLISH
            crossedOderBlock := true
            if internal
                luxCurrentAlerts.internalBullishOrderBlock := true
            else
                luxCurrentAlerts.swingBullishOrderBlock    := true
        if crossedOderBlock                    
            orderBlocks.remove(index)            

luxStoreOrdeBlock(luxPivot p_ivot, bool internal = false, int bias) =>
    if (not internal and showSwingOrderBlocksInput) or (internal and showInternalOrderBlocksInput)

        array<float> a_rray = na
        int parsedIndex = na

        if bias == LUX_BEARISH
            a_rray      := luxParsedHighs.slice(p_ivot.barIndex,bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.max())  
        else
            a_rray      := luxParsedLows.slice(p_ivot.barIndex,bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.min())                        

        luxOrderBlock o_rderBlock          = luxOrderBlock.new(luxParsedHighs.get(parsedIndex), luxParsedLows.get(parsedIndex), luxTimes.get(parsedIndex),bias)
        array<luxOrderBlock> orderBlocks   = internal ? luxInternalOrderBlocks : luxSwingOrderBlocks
        
        if orderBlocks.size() >= 100
            orderBlocks.pop()
        orderBlocks.unshift(o_rderBlock)

luxDrawOrderBlocks(bool internal = false) =>        
    array<luxOrderBlock> orderBlocks = internal ? luxInternalOrderBlocks : luxSwingOrderBlocks
    orderBlocksSize = orderBlocks.size()

    if orderBlocksSize > 0        
        maxOrderBlocks                      = internal ? internalOrderBlocksSizeInput : swingOrderBlocksSizeInput
        array<luxOrderBlock> parsedOrdeBlocks  = orderBlocks.slice(0, math.min(maxOrderBlocks,orderBlocksSize))
        array<box> b_oxes                   = internal ? luxInternalOrderBlocksBoxes : luxSwingOrderBlocksBoxes        

        for [index,eachOrderBlock] in parsedOrdeBlocks
            orderBlockColor = styleInput == LUX_MONOCHROME ? (eachOrderBlock.bias == LUX_BEARISH ? color.new(LUX_MONO_BEARISH,80) : color.new(LUX_MONO_BULLISH,80)) : internal ? (eachOrderBlock.bias == LUX_BEARISH ? internalBearishOrderBlockColor : internalBullishOrderBlockColor) : (eachOrderBlock.bias == LUX_BEARISH ? swingBearishOrderBlockColor : swingBullishOrderBlockColor)

            box b_ox        = b_oxes.get(index)
            b_ox.set_top_left_point(    chart.point.new(eachOrderBlock.barTime,na,eachOrderBlock.barHigh))
            b_ox.set_bottom_right_point(chart.point.new(last_bar_time,na,eachOrderBlock.barLow))        
            b_ox.set_border_color(      internal ? na : orderBlockColor)
            b_ox.set_bgcolor(           orderBlockColor)

luxDisplayStructure(bool internal = false) =>
    var bullishBar = true
    var bearishBar = true

    if internalFilterConfluenceInput
        bullishBar := high - math.max(close, open) > math.min(close, open - low)
        bearishBar := high - math.max(close, open) < math.min(close, open - low)
    
    luxPivot p_ivot    = internal ? luxInternalHigh : luxSwingHigh
    luxTrend t_rend    = internal ? luxInternalTrend : luxSwingTrend

    lineStyle       = internal ? line.style_dashed : line.style_solid
    labelSize       = internal ? internalStructureSize : swingStructureSize

    extraCondition  = internal ? luxInternalHigh.currentLevel != luxSwingHigh.currentLevel and bullishBar : true
    bullishColor    = styleInput == LUX_MONOCHROME ? LUX_MONO_BULLISH : internal ? internalBullColorInput : swingBullColorInput

    if ta.crossover(close,p_ivot.currentLevel) and not p_ivot.crossed and extraCondition
        string tag = t_rend.bias == LUX_BEARISH ? LUX_CHOCH : LUX_BOS

        if internal
            luxCurrentAlerts.internalBullishCHoCH  := tag == LUX_CHOCH
            luxCurrentAlerts.internalBullishBOS    := tag == LUX_BOS
        else
            luxCurrentAlerts.swingBullishCHoCH     := tag == LUX_CHOCH
            luxCurrentAlerts.swingBullishBOS       := tag == LUX_BOS

        p_ivot.crossed  := true
        t_rend.bias     := LUX_BULLISH

        displayCondition = internal ? showInternalsInput and (showInternalBullInput == LUX_ALL or (showInternalBullInput == LUX_BOS and tag != LUX_CHOCH) or (showInternalBullInput == LUX_CHOCH and tag == LUX_CHOCH)) : showStructureInput and (showSwingBullInput == LUX_ALL or (showSwingBullInput == LUX_BOS and tag != LUX_CHOCH) or (showSwingBullInput == LUX_CHOCH and tag == LUX_CHOCH))

        if displayCondition                        
            luxDrawStructure(p_ivot,tag,bullishColor,lineStyle,label.style_label_down,labelSize)

        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            luxStoreOrdeBlock(p_ivot,internal,LUX_BULLISH)

    p_ivot          := internal ? luxInternalLow : luxSwingLow    
    extraCondition  := internal ? luxInternalLow.currentLevel != luxSwingLow.currentLevel and bearishBar : true
    bearishColor    = styleInput == LUX_MONOCHROME ? LUX_MONO_BEARISH : internal ? internalBearColorInput : swingBearColorInput

    if ta.crossunder(close,p_ivot.currentLevel) and not p_ivot.crossed and extraCondition
        string tag = t_rend.bias == LUX_BULLISH ? LUX_CHOCH : LUX_BOS

        if internal
            luxCurrentAlerts.internalBearishCHoCH  := tag == LUX_CHOCH
            luxCurrentAlerts.internalBearishBOS    := tag == LUX_BOS
        else
            luxCurrentAlerts.swingBearishCHoCH     := tag == LUX_CHOCH
            luxCurrentAlerts.swingBearishBOS       := tag == LUX_BOS

        p_ivot.crossed := true
        t_rend.bias := LUX_BEARISH

        displayCondition = internal ? showInternalsInput and (showInternalBearInput == LUX_ALL or (showInternalBearInput == LUX_BOS and tag != LUX_CHOCH) or (showInternalBearInput == LUX_CHOCH and tag == LUX_CHOCH)) : showStructureInput and (showSwingBearInput == LUX_ALL or (showSwingBearInput == LUX_BOS and tag != LUX_CHOCH) or (showSwingBearInput == LUX_CHOCH and tag == LUX_CHOCH))
        
        if displayCondition                        
            luxDrawStructure(p_ivot,tag,bearishColor,lineStyle,label.style_label_up,labelSize)

        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            luxStoreOrdeBlock(p_ivot,internal,LUX_BEARISH)

luxFairValueGapBox(leftTime,rightTime,topPrice,bottomPrice,boxColor) => box.new(chart.point.new(leftTime,na,topPrice),chart.point.new(rightTime + fairValueGapsExtendInput * (time-time[1]),na,bottomPrice), xloc=xloc.bar_time, border_color = boxColor, bgcolor = boxColor)

luxDeleteFairValueGaps() =>
    for [index,eachFairValueGap] in luxFairValueGaps
        if (low < eachFairValueGap.bottom and eachFairValueGap.bias == LUX_BULLISH) or (high > eachFairValueGap.top and eachFairValueGap.bias == LUX_BEARISH)
            eachFairValueGap.topBox.delete()
            eachFairValueGap.bottomBox.delete()
            luxFairValueGaps.remove(index)
    
luxDrawFairValueGaps() => 
    [lastClose, lastOpen, lastTime, currentHigh, currentLow, currentTime, last2High, last2Low] = request.security(syminfo.tickerid, fairValueGapsTimeframeInput, [close[1], open[1], time[1], high[0], low[0], time[0], high[2], low[2]],lookahead = barmerge.lookahead_on)

    barDeltaPercent     = (lastClose - lastOpen) / (lastOpen * 100)
    newTimeframe        = timeframe.change(fairValueGapsTimeframeInput)
    threshold           = fairValueGapsThresholdInput ? ta.cum(math.abs(newTimeframe ? barDeltaPercent : 0)) / bar_index * 2 : 0

    bullishFairValueGap = currentLow > last2High and lastClose > last2High and barDeltaPercent > threshold and newTimeframe
    bearishFairValueGap = currentHigh < last2Low and lastClose < last2Low and -barDeltaPercent > threshold and newTimeframe

    if bullishFairValueGap
        luxCurrentAlerts.bullishFairValueGap := true
        luxFairValueGaps.unshift(luxFairValueGap.new(currentLow,last2High,LUX_BULLISH,luxFairValueGapBox(lastTime,currentTime,currentLow,math.avg(currentLow,last2High),fairValueGapBullishColor),luxFairValueGapBox(lastTime,currentTime,math.avg(currentLow,last2High),last2High,fairValueGapBullishColor)))
    if bearishFairValueGap
        luxCurrentAlerts.bearishFairValueGap := true
        luxFairValueGaps.unshift(luxFairValueGap.new(currentHigh,last2Low,LUX_BEARISH,luxFairValueGapBox(lastTime,currentTime,currentHigh,math.avg(currentHigh,last2Low),fairValueGapBearishColor),luxFairValueGapBox(lastTime,currentTime,math.avg(currentHigh,last2Low),last2Low,fairValueGapBearishColor)))

luxGetStyle(string style) =>
    switch style
        LUX_SOLID => line.style_solid
        LUX_DASHED => line.style_dashed
        LUX_DOTTED => line.style_dotted

luxDrawLevels(string timeframe, bool sameTimeframe, string style, color levelColor) =>
    [topLevel, bottomLevel, leftTime, rightTime] = request.security(syminfo.tickerid, timeframe, [high[1], low[1], time[1], time],lookahead = barmerge.lookahead_on)

    float parsedTop         = sameTimeframe ? high : topLevel
    float parsedBottom      = sameTimeframe ? low : bottomLevel    

    int parsedLeftTime      = sameTimeframe ? time : leftTime
    int parsedRightTime     = sameTimeframe ? time : rightTime

    int parsedTopTime       = time
    int parsedBottomTime    = time

    if not sameTimeframe
        int leftIndex               = luxTimes.binary_search_rightmost(parsedLeftTime)
        int rightIndex              = luxTimes.binary_search_rightmost(parsedRightTime)

        array<int> timeArray        = luxTimes.slice(leftIndex,rightIndex)
        array<float> topArray       = luxHighs.slice(leftIndex,rightIndex)
        array<float> bottomArray    = luxLows.slice(leftIndex,rightIndex)

        parsedTopTime               := timeArray.size() > 0 ? timeArray.get(topArray.indexof(topArray.max())) : luxInitialTime
        parsedBottomTime            := timeArray.size() > 0 ? timeArray.get(bottomArray.indexof(bottomArray.min())) : luxInitialTime

    var line topLine        = line.new(na, na, na, na, xloc = xloc.bar_time, color = levelColor, style = luxGetStyle(style))
    var line bottomLine     = line.new(na, na, na, na, xloc = xloc.bar_time, color = levelColor, style = luxGetStyle(style))
    var label topLabel      = label.new(na, na, xloc = xloc.bar_time, text = str.format('P{0}H',timeframe), color=color(na), textcolor = levelColor, size = size.small, style = label.style_label_left)
    var label bottomLabel   = label.new(na, na, xloc = xloc.bar_time, text = str.format('P{0}L',timeframe), color=color(na), textcolor = levelColor, size = size.small, style = label.style_label_left)

    topLine.set_first_point(    chart.point.new(parsedTopTime,na,parsedTop))
    topLine.set_second_point(   chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedTop))   
    topLabel.set_point(         chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedTop))

    bottomLine.set_first_point( chart.point.new(parsedBottomTime,na,parsedBottom))    
    bottomLine.set_second_point(chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedBottom))
    bottomLabel.set_point(      chart.point.new(last_bar_time + 20 * (time-time[1]),na,parsedBottom))

luxHigherTimeframe(string timeframe) => timeframe.in_seconds() > timeframe.in_seconds(timeframe)

luxUpdateTrailingExtremes() =>
    luxTrailing.top            := math.max(high,luxTrailing.top)
    luxTrailing.lastTopTime    := luxTrailing.top == high ? time : luxTrailing.lastTopTime
    luxTrailing.bottom         := math.min(low,luxTrailing.bottom)
    luxTrailing.lastBottomTime := luxTrailing.bottom == low ? time : luxTrailing.lastBottomTime

luxDrawHighLowSwings() =>
    var line topLine        = line.new(na, na, na, na, color = swingBearishColor, xloc = xloc.bar_time)
    var line bottomLine     = line.new(na, na, na, na, color = swingBullishColor, xloc = xloc.bar_time)
    var label topLabel      = label.new(na, na, color=color(na), textcolor = swingBearishColor, xloc = xloc.bar_time, style = label.style_label_down, size = size.tiny)
    var label bottomLabel   = label.new(na, na, color=color(na), textcolor = swingBullishColor, xloc = xloc.bar_time, style = label.style_label_up, size = size.tiny)

    rightTimeBar            = last_bar_time + 20 * (time - time[1])

    topLine.set_first_point(    chart.point.new(luxTrailing.lastTopTime, na, luxTrailing.top))
    topLine.set_second_point(   chart.point.new(rightTimeBar, na, luxTrailing.top))
    topLabel.set_point(         chart.point.new(rightTimeBar, na, luxTrailing.top))
    topLabel.set_text(          luxSwingTrend.bias == LUX_BEARISH ? 'Strong High' : 'Weak High')

    bottomLine.set_first_point( chart.point.new(luxTrailing.lastBottomTime, na, luxTrailing.bottom))
    bottomLine.set_second_point(chart.point.new(rightTimeBar, na, luxTrailing.bottom))
    bottomLabel.set_point(      chart.point.new(rightTimeBar, na, luxTrailing.bottom))
    bottomLabel.set_text(       luxSwingTrend.bias == LUX_BULLISH ? 'Strong Low' : 'Weak Low')

luxDrawZone(float labelLevel, int labelIndex, float top, float bottom, string tag, color zoneColor, string style) =>
    var label l_abel    = label.new(na,na,text = tag, color=color(na),textcolor = zoneColor, style = style, size = size.small)
    var box b_ox        = box.new(na,na,na,na,bgcolor = color.new(zoneColor,80),border_color = color(na), xloc = xloc.bar_time)

    b_ox.set_top_left_point(    chart.point.new(luxTrailing.barTime,na,top))
    b_ox.set_bottom_right_point(chart.point.new(last_bar_time,na,bottom))

    l_abel.set_point(           chart.point.new(na,labelIndex,labelLevel))

luxDrawPremiumDiscountZones() =>
    luxDrawZone(luxTrailing.top, math.round(0.5*(luxTrailing.barIndex + last_bar_index)), luxTrailing.top, 0.95*luxTrailing.top + 0.05*luxTrailing.bottom, 'Premium', luxPremiumZoneColor, label.style_label_down)

    equilibriumLevel = math.avg(luxTrailing.top, luxTrailing.bottom)
    luxDrawZone(equilibriumLevel, last_bar_index, 0.525*luxTrailing.top + 0.475*luxTrailing.bottom, 0.525*luxTrailing.bottom + 0.475*luxTrailing.top, 'Equilibrium', equilibriumZoneColorInput, label.style_label_left)

    luxDrawZone(luxTrailing.bottom, math.round(0.5*(luxTrailing.barIndex + last_bar_index)), 0.95*luxTrailing.bottom + 0.05*luxTrailing.top, luxTrailing.bottom, 'Discount', luxDiscountZoneColor, label.style_label_up)

parsedOpen  = showTrendInput ? open : na
candleColor = luxInternalTrend.bias == LUX_BULLISH ? swingBullishColor : swingBearishColor
plotcandle(parsedOpen,high,low,close,color = candleColor, wickcolor = candleColor, bordercolor = candleColor)

if showHighLowSwingsInput or showPremiumDiscountZonesInput
    luxUpdateTrailingExtremes()

    if showHighLowSwingsInput
        luxDrawHighLowSwings()

    if showPremiumDiscountZonesInput
        luxDrawPremiumDiscountZones()

if showFairValueGapsInput
    luxDeleteFairValueGaps()

luxGetCurrentStructure(swingsLengthInput,false)
luxGetCurrentStructure(5,false,true)

if showEqualHighsLowsInput
    luxGetCurrentStructure(equalHighsLowsLengthInput,true)

if showInternalsInput or showInternalOrderBlocksInput or showTrendInput
    luxDisplayStructure(true)

if showStructureInput or showSwingOrderBlocksInput or showHighLowSwingsInput
    luxDisplayStructure()

if showInternalOrderBlocksInput
    luxDeleteOrderBlocks(true)

if showSwingOrderBlocksInput
    luxDeleteOrderBlocks()

if showFairValueGapsInput
    luxDrawFairValueGaps()

if barstate.islastconfirmedhistory or barstate.islast
    if showInternalOrderBlocksInput        
        luxDrawOrderBlocks(true)
        
    if showSwingOrderBlocksInput        
        luxDrawOrderBlocks()

luxLastBarIndex    := luxCurrentBarIndex
luxCurrentBarIndex := bar_index
luxNewBar          = luxCurrentBarIndex != luxLastBarIndex

if barstate.islastconfirmedhistory or (barstate.isrealtime and luxNewBar)
    if showDailyLevelsInput and not luxHigherTimeframe('D')
        luxDrawLevels('D',timeframe.isdaily,dailyLevelsStyleInput,dailyLevelsColorInput)

    if showWeeklyLevelsInput and not luxHigherTimeframe('W')
        luxDrawLevels('W',timeframe.isweekly,weeklyLevelsStyleInput,weeklyLevelsColorInput)

    if showMonthlyLevelsInput and not luxHigherTimeframe('M')
        luxDrawLevels('M',timeframe.ismonthly,monthlyLevelsStyleInput,monthlyLevelsColorInput)



// =============================================================================
// 4. DECISION ENGINE & SIGNALS (ORIGINAL)
// =============================================================================
var float q_score = 50.0

// 1. Trend Score
score_trend = 0
if is_st_bull
    score_trend += 20
if t_h1 == 1
    score_trend += 10
if t_h4 == 1
    score_trend += 10
if not is_st_bull
    score_trend -= 20
if t_h1 == -1
    score_trend -= 10
if t_h4 == -1
    score_trend -= 10

// 2. Momentum Score
score_mom = 0
if rsi_val > 50 
    score_mom += 10
if ut_pos == 1
    score_mom += 20
if rsi_val < 50
    score_mom -= 10
if ut_pos == -1
    score_mom -= 20

// 3. SMC / Market Structure Score (LuxAlgo)
score_smc = 0
if luxSwingTrend.bias == LUX_BULLISH
    score_smc += 20
if luxSwingTrend.bias == LUX_BEARISH
    score_smc -= 20

if luxInternalTrend.bias == LUX_BULLISH
    score_smc += 10
if luxInternalTrend.bias == LUX_BEARISH
    score_smc -= 10

// Boost score if recent Break of Structure
if luxCurrentAlerts.swingBullishBOS or luxCurrentAlerts.swingBullishCHoCH
    score_smc += 15
if luxCurrentAlerts.swingBearishBOS or luxCurrentAlerts.swingBearishCHoCH
    score_smc -= 15

// Final Score Calculation
// Base: 50. Trend: +/- 40. Mom: +/- 30. SMC: +/- 45.
final_score = 50 + score_trend + score_mom + score_smc
final_score := math.max(0, math.min(100, final_score))

buy_signal = final_score >= 80
sell_signal = final_score <= 20

// Time since last signal
last_buy = ta.barssince(buy_signal)
last_sell = ta.barssince(sell_signal)

// =============================================================================
// 5. PLANNING & EXECUTION (TP/SL CALCULATOR)
// =============================================================================
atr = ta.atr(14)

pred_stop_buy  = close - (atr * sl_mult)
pred_target_buy = close + (atr * tp_mult)
pred_stop_sell = close + (atr * sl_mult)
pred_target_sell = close - (atr * tp_mult)

est_profit_buy = ((pred_target_buy - close) / close) * 100
est_profit_sell = ((close - pred_target_sell) / close) * 100

// Execution
if buy_signal
    strategy.entry("LONG", strategy.long)
    strategy.exit("TP/SL", "LONG", stop = pred_stop_buy, limit = pred_target_buy)

if sell_signal
    strategy.entry("SHORT", strategy.short)
    strategy.exit("TP/SL", "SHORT", stop = pred_stop_sell, limit = pred_target_sell)

// =============================================================================
// 6. ENHANCED VISUALIZATION
// =============================================================================

plotshape(show_signals and buy_signal and sz_input == "Tiny", "BUY", shape.labelup, location.belowbar, col_buy, 0, "BUY", c_text, size = size.tiny)
plotshape(show_signals and sell_signal and sz_input == "Tiny", "SELL", shape.labeldown, location.abovebar, col_sell, 0, "SELL", c_text, size = size.tiny)

plotshape(show_signals and buy_signal and sz_input == "Small", "BUY", shape.labelup, location.belowbar, col_buy, 0, "BUY", c_text, size = size.small)
plotshape(show_signals and sell_signal and sz_input == "Small", "SELL", shape.labeldown, location.abovebar, col_sell, 0, "SELL", c_text, size = size.small)

plotshape(show_signals and buy_signal and sz_input == "Normal", "BUY", shape.labelup, location.belowbar, col_buy, 0, "BUY", c_text, size = size.normal)
plotshape(show_signals and sell_signal and sz_input == "Normal", "SELL", shape.labeldown, location.abovebar, col_sell, 0, "SELL", c_text, size = size.normal)

plotshape(show_signals and buy_signal and sz_input == "Large", "BUY", shape.labelup, location.belowbar, col_buy, 0, "BUY", c_text, size = size.large)
plotshape(show_signals and sell_signal and sz_input == "Large", "SELL", shape.labeldown, location.abovebar, col_sell, 0, "SELL", c_text, size = size.large)

plotshape(show_signals and buy_signal and sz_input == "Huge", "BUY", shape.labelup, location.belowbar, col_buy, 0, "BUY", c_text, size = size.huge)
plotshape(show_signals and sell_signal and sz_input == "Huge", "SELL", shape.labeldown, location.abovebar, col_sell, 0, "SELL", c_text, size = size.huge)

// Engulfing Patterns Plotting
plotshape(show_engulf and bullishEngulfing, title="Bullish Engulfing", style = shape.triangleup, location = location.belowbar, color = col_bull_eng, size = size.tiny)
plotshape(show_engulf and bearishEngulfing, title="Bearish Engulfing", style = shape.triangledown , location = location.abovebar, color = col_bear_eng, size = size.tiny)

// 3 EMA Plotting
plot(show_ema ? out1 : na, title="EMA1", color=col_ema1, linewidth=2)
plot(show_ema ? out2 : na, title="EMA2", color=col_ema2, linewidth=2)
plot(show_ema ? out3 : na, title="EMA3", color=col_ema3, linewidth=2)

// C. Draw Professional TP/SL Lines
var line l_entry = na
var line l_tp    = na
var line l_sl    = na
var label lbl_tp = na
var label lbl_sl = na

if show_tpsl and (buy_signal or sell_signal)
    // Clear old drawings for cleaner view (focus on latest)
    line.delete(l_entry)
    line.delete(l_tp)
    line.delete(l_sl)
    label.delete(lbl_tp)
    label.delete(lbl_sl)
    
    // Determine Targets
    target_price = buy_signal ? pred_target_buy : pred_target_sell
    stop_price   = buy_signal ? pred_stop_buy : pred_stop_sell
    entry_price  = close
    sig_col      = buy_signal ? col_buy : col_sell
    
    // Draw Entry Line (Dotted)
    l_entry := line.new(bar_index, entry_price, bar_index + 10, entry_price, color = color.gray, style = line.style_dotted)
    
    // Draw TP Line (Solid, Thick)
    l_tp := line.new(bar_index, target_price, bar_index + 10, target_price, color = sig_col, style = line.style_solid, width = 2)
    lbl_tp := label.new(bar_index + 10, target_price, "TP: " + str.tostring(target_price, format.mintick), color = sig_col, style = label.style_label_left, textcolor = color.black, size = size.tiny)
    
    // Draw SL Line (Solid, Thick)
    l_sl := line.new(bar_index, stop_price, bar_index + 10, stop_price, color = color.red, style = line.style_solid, width = 2)
    lbl_sl := label.new(bar_index + 10, stop_price, "SL: " + str.tostring(stop_price, format.mintick), color = color.red, style = label.style_label_left, textcolor = color.white, size = size.tiny)


// =============================================================================
// 7. BLOOMBERG TERMINAL DASHBOARD
// =============================================================================
var table dash = table.new(dash_pos == "Top Right" ? position.top_right : dash_pos == "Bottom Right" ? position.bottom_right : dash_pos == "Bottom Left" ? position.bottom_left : dash_pos == "Top Left" ? position.top_left : position.middle_right, 4, 10, bgcolor = c_bg, border_width = 1, frame_color = color.white, border_color = color.gray)

if show_dash and barstate.islast
    // -- HEADER --
    header_txt = syminfo.ticker + " | " + timeframe.period + " | " + (use_indo ? "PASAR: " : "MARKET: ") + (barstate.isrealtime ? "LIVE ðŸ”´" : "CLOSED âš«")
    table.cell(dash, 0, 0, header_txt, text_color = color.white, text_size = size.normal, text_halign = text.align_left)
    table.merge_cells(dash, 0, 0, 3, 0)

    // -- ROW 1: MARKET CONTEXT --
    table.cell(dash, 0, 1, "INDIKATOR", text_color = color.gray, text_size = size.small)
    table.cell(dash, 1, 1, "STATUS", text_color = color.gray, text_size = size.small)
    table.cell(dash, 2, 1, "VALUE", text_color = color.gray, text_size = size.small)
    table.cell(dash, 3, 1, "TF TREND", text_color = color.gray, text_size = size.small)

    // Row 2: Trend
    t_txt = is_st_bull ? "BULLISH" : "BEARISH"
    t_col = is_st_bull ? c_bull_std : c_bear_std
    table.cell(dash, 0, 2, "Main Trend", text_color = color.white, text_size = size.small)
    table.cell(dash, 1, 2, t_txt, text_color = t_col, bgcolor = color.new(t_col, 90), text_size = size.small)
    table.cell(dash, 2, 2, str.tostring(close, format.mintick), text_color = color.silver, text_size = size.small)
    
    map_txt = (t_h1 == 1 ? "1H:ðŸŸ¢" : "1H:ðŸ”´") + " " + (t_h4 == 1 ? "4H:ðŸŸ¢" : "4H:ðŸ”´")
    table.cell(dash, 3, 2, map_txt, text_color = color.white, text_size = size.small)

    // Row 3: RSI & Volatility
    r_txt = rsi_val > 55 ? "OVERBOUGHT" : rsi_val < 45 ? "OVERSOLD" : "NEUTRAL"
    r_col = rsi_val > 55 ? c_bear_std : rsi_val < 45 ? c_bull_std : c_neut
    table.cell(dash, 0, 3, "RSI (" + str.tostring(rsi_len) + ")", text_color = color.white, text_size = size.small)
    table.cell(dash, 1, 3, r_txt, text_color = r_col, text_size = size.small)
    table.cell(dash, 2, 3, str.tostring(rsi_val, "#.0"), text_color = color.silver, text_size = size.small)
    table.cell(dash, 3, 3, ut_pos == 1 ? "VOL: UP" : "VOL: DOWN", text_color = ut_pos == 1 ? c_bull_std : c_bear_std, text_size = size.small)

    // -- ROW 4: SIGNAL TIMING --
    last_sig_txt = "WAITING..."
    if last_buy < last_sell and last_buy < 100
        last_sig_txt := "BUY (" + str.tostring(last_buy) + " bars ago)"
    else if last_sell < last_buy and last_sell < 100
        last_sig_txt := "SELL (" + str.tostring(last_sell) + " bars ago)"
    
    table.cell(dash, 0, 4, "LAST SIGNAL", text_color = color.white, text_size = size.small)
    table.cell(dash, 1, 4, last_sig_txt, text_color = color.yellow, text_size = size.small)
    table.merge_cells(dash, 1, 4, 3, 4)

    // -- ROW 5: POSITION STATUS --
    pos_size = strategy.position_size
    pos_pnl  = strategy.openprofit
    pos_txt = pos_size > 0 ? "LONG (OPEN)" : pos_size < 0 ? "SHORT (OPEN)" : "NO POSITION"
    pos_col = pos_size > 0 ? c_bull_std : pos_size < 0 ? c_bear_std : color.gray
    
    table.cell(dash, 0, 5, "POSISI AKTIF", text_color = color.white, text_size = size.small)
    table.cell(dash, 1, 5, pos_txt, text_color = pos_col, bgcolor = color.new(pos_col, 80), text_size = size.small)
    table.cell(dash, 2, 5, "PnL: " + str.tostring(pos_pnl, "#.##"), text_color = pos_pnl >= 0 ? c_bull_std : c_bear_std, text_size = size.small)
    table.merge_cells(dash, 2, 5, 3, 5)

    // -- ROW 6: SMC STATUS (NEW) --
    smc_swing_txt = luxSwingTrend.bias == LUX_BULLISH ? "SWING: BULL" : "SWING: BEAR"
    smc_int_txt   = luxInternalTrend.bias == LUX_BULLISH ? "INT: BULL" : "INT: BEAR"
    smc_col       = luxSwingTrend.bias == LUX_BULLISH ? c_bull_std : c_bear_std
    
    table.cell(dash, 0, 6, "SMC FLUX", text_color = color.white, text_size = size.small)
    table.cell(dash, 1, 6, smc_swing_txt, text_color = smc_col, text_size = size.small)
    table.cell(dash, 2, 6, smc_int_txt, text_color = luxInternalTrend.bias == LUX_BULLISH ? c_bull_std : c_bear_std, text_size = size.small)
    table.cell(dash, 3, 6, "Scr: " + str.tostring(score_smc), text_color = color.silver, text_size = size.small)

    // -- ROW 7: AI TRADE PLAN (PREDICTION) --
    // Show predicted entry/TP/SL based on current AI bias
    bias = final_score >= 50 ? 1 : -1
    t_tp = bias == 1 ? pred_target_buy : pred_target_sell
    t_sl = bias == 1 ? pred_stop_buy : pred_stop_sell
    t_prof = bias == 1 ? est_profit_buy : est_profit_sell
    
    table.cell(dash, 0, 7, "AI PREDICTION", text_color = color.white, text_size = size.small)
    table.cell(dash, 1, 7, bias == 1 ? "ZONA BUY" : "ZONA SELL", text_color = bias == 1 ? c_bull_std : c_bear_std, text_size = size.small)
    table.cell(dash, 2, 7, "Est. Profit", text_color = color.gray, text_size = size.small)
    table.cell(dash, 3, 7, str.tostring(t_prof, "#.##") + "%", text_color = c_bull_std, text_size = size.small)

    // -- ROW 8: TARGETS --
    table.cell(dash, 0, 8, "TARGET PRICE", text_color = color.gray, text_size = size.small)
    table.cell(dash, 1, 8, "TP: " + str.tostring(t_tp, format.mintick), text_color = c_bull_std, text_size = size.small)
    table.cell(dash, 2, 8, "SL: " + str.tostring(t_sl, format.mintick), text_color = c_bear_std, text_size = size.small)
    table.cell(dash, 3, 8, "Score: " + str.tostring(final_score), text_color = final_score > 50 ? c_bull_std : c_bear_std, text_size = size.small)

